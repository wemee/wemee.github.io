---
import BaseLayout from '@/layouts/BaseLayout.astro';
import Navbar from '@/components/Navbar.astro';
---

<BaseLayout
  title="å¿«é€Ÿè¨˜äº‹æœ¬ - ç§’é–‹ã€è‡ªå‹•å„²å­˜ã€å¯è²¼åœ– | å¯¦ç”¨å·¥å…·"
  description="æ¥µé€Ÿé–‹å•Ÿçš„ç·šä¸Šè¨˜äº‹æœ¬ã€‚è‡ªå‹•å„²å­˜åˆ°ç€è¦½å™¨ï¼Œæ”¯æ´è²¼ä¸Šåœ–ç‰‡ï¼Œå®Œå…¨é›¢ç·šå¯ç”¨ã€‚éš¨é–‹éš¨è¨˜ï¼Œéˆæ„Ÿä¸æµå¤±ã€‚"
>
  <Navbar currentPage="tools" />

  <div class="container-fluid p-0 d-flex flex-column h-100-vh-custom">
    <!-- Toolbar / Header (Mobile friendly) -->
    <div class="bg-light border-bottom p-2 d-flex align-items-center justify-content-between">
      <div class="d-flex align-items-center">
        <button id="toggleSidebarBtn" class="btn btn-outline-secondary me-2">
          <span class="d-none d-md-inline">â˜° åˆ—è¡¨</span>
          <span class="d-md-none">â˜°</span>
        </button>
        <h1 class="h5 mb-0 fw-bold text-nowrap user-select-none">ğŸ“ å¿«é€Ÿè¨˜äº‹æœ¬</h1>
        <span id="saveStatus" class="ms-3 badge bg-success opacity-0 transition-opacity">å·²å„²å­˜</span>
      </div>
      <div>
        <button id="newNoteBtn" class="btn btn-primary btn-sm">
          + æ–°ç­†è¨˜
        </button>
      </div>
    </div>

    <div class="d-flex flex-grow-1 overflow-hidden">
      <!-- Sidebar (Note List) -->
      <div id="sidebar" class="bg-light border-end d-flex flex-column sidebar-transition open">
        <div class="p-2 border-bottom">
          <input type="text" id="searchNotes" class="form-control form-control-sm" placeholder="æœå°‹ç­†è¨˜...">
        </div>
        <div id="noteList" class="list-group list-group-flush overflow-auto flex-grow-1">
          <!-- Note items will be injected here -->
        </div>
      </div>

      <!-- Main Editor Area -->
      <div class="flex-grow-1 position-relative d-flex flex-column bg-white">
        <div 
          id="editor" 
          contenteditable="true" 
          class="flex-grow-1 p-4 outline-none overflow-auto"
          spellcheck="false"
        ></div>
        
        <!-- Placeholder (Overlaid) -->
        <div id="editorPlaceholder" class="position-absolute p-4 text-muted pointer-events-none">
          é–‹å§‹æ‰“å­—...<br>
          <small>æ”¯æ´è²¼ä¸Šæˆªåœ– (Ctrl+V)</small>
        </div>
      </div>
    </div>
  </div>
</BaseLayout>

<style>
  .h-100-vh-custom {
    height: calc(100vh - 56px); /* Adjust based on Navbar height approx */
  }

  .sidebar-transition {
    width: 250px;
    transition: margin-left 0.3s ease;
    flex-shrink: 0;
  }

  .sidebar-transition.closed {
    margin-left: -250px;
  }
  
  /* Mobile Sidebar behavior */
  @media (max-width: 768px) {
    .sidebar-transition {
      width: 100%;
      position: absolute;
      top: 0;
      bottom: 0;
      z-index: 1000;
      margin-left: -100%;
    }
    .sidebar-transition.open {
      margin-left: 0;
      box-shadow: 2px 0 10px rgba(0,0,0,0.1);
    }
  }

  #editor:focus {
    outline: none;
  }

  #editorPlaceholder {
    top: 0;
    left: 0;
    pointer-events: none; /* Let clicks pass through to editor */
    opacity: 0.5;
    font-size: 1.2rem;
  }

  /* Hide placeholder when editor has content */
  #editor:not(:empty) + #editorPlaceholder {
    display: none;
  }
  
  /* Images in the editor */
  #editor img {
    max-width: 100%;
    height: auto;
    border-radius: 8px;
    margin: 10px 0;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
  }

  /* Note List Items */
  .note-item {
    cursor: pointer;
    border-left: 3px solid transparent;
  }
  .note-item:hover {
    background-color: #f8f9fa;
  }
  .note-item.active {
    background-color: #e9ecef;
    border-left-color: var(--bs-primary);
    font-weight: 500;
  }
  .note-item .delete-btn {
    opacity: 0; 
    transition: opacity 0.2s;
  }
  .note-item:hover .delete-btn { 
    opacity: 1; 
  }
</style>

<script is:inline>
  // ==========================================
  // IndexedDB Manager
  // ==========================================
  const DB_NAME = 'WemeeQuickMemo';
  const DB_VERSION = 1;
  const STORE_NAME = 'notes';

  let db;
  let currentNoteId = null;

  async function initDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(DB_NAME, DB_VERSION);

      request.onerror = (event) => {
        console.error("Database error: " + event.target.errorCode);
        reject(event.target.error);
      };

      request.onsuccess = (event) => {
        db = event.target.result;
        resolve(db);
      };

      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        const objectStore = db.createObjectStore(STORE_NAME, { keyPath: "id" });
        objectStore.createIndex("updatedAt", "updatedAt", { unique: false });
      };
    });
  }

  async function getAllNotes() {
    return new Promise((resolve, reject) => {
      const transaction = db.transaction([STORE_NAME], "readonly");
      const objectStore = transaction.objectStore(STORE_NAME);
      const index = objectStore.index("updatedAt");
      const request = index.openCursor(null, 'prev'); // Latest first
      const notes = [];

      request.onsuccess = (event) => {
        const cursor = event.target.result;
        if (cursor) {
          notes.push(cursor.value);
          cursor.continue();
        } else {
          resolve(notes);
        }
      };
      
      request.onerror = (e) => reject(e);
    });
  }

  async function saveNote(note) {
    return new Promise((resolve, reject) => {
      const transaction = db.transaction([STORE_NAME], "readwrite");
      const objectStore = transaction.objectStore(STORE_NAME);
      const request = objectStore.put(note);

      request.onsuccess = () => resolve(request.result);
      request.onerror = (e) => reject(e);
    });
  }

  async function deleteNoteFromDB(id) {
    return new Promise((resolve, reject) => {
      const transaction = db.transaction([STORE_NAME], "readwrite");
      const objectStore = transaction.objectStore(STORE_NAME);
      const request = objectStore.delete(id);

      request.onsuccess = () => resolve();
      request.onerror = (e) => reject(e);
    });
  }

  // ==========================================
  // App Logic
  // ==========================================
  const editor = document.getElementById('editor');
  const noteList = document.getElementById('noteList');
  const saveStatus = document.getElementById('saveStatus');
  const toggleSidebarBtn = document.getElementById('toggleSidebarBtn');
  const sidebar = document.getElementById('sidebar');
  const searchNotes = document.getElementById('searchNotes');
  
  let allNotesCache = [];

  // Initialize
  initDB().then(async () => {
    await refreshNoteList();
    
    // Auto-load most recent note or create new
    if (allNotesCache.length > 0) {
      loadNote(allNotesCache[0].id, allNotesCache[0]);
    } else {
      createNewNote(false); // don't auto-save immediately on init empty
    }
  });

  // Event Listeners
  document.getElementById('newNoteBtn').addEventListener('click', () => {
    createNewNote();
    // On mobile, close sidebar after creating new note
    if (window.innerWidth <= 768) {
      sidebar.classList.remove('open');
      sidebar.classList.add('closed');
    }
  });

  // Auto-save debouncer
  let saveTimeout;
  editor.addEventListener('input', () => {
    if (saveTimeout) clearTimeout(saveTimeout);
    saveStatus.classList.remove('opacity-100');
    saveStatus.classList.add('opacity-0');
    
    saveTimeout = setTimeout(async () => {
      await performSave();
    }, 1000); // 1 sec delay
  });

  // Paste handler (images)
  editor.addEventListener('paste', (e) => {
    // Just default behavior usually handles text
    // Handle Images specifically to resize/optimize if needed in future
    // For now, default browser paste behavior for images (data URI) is acceptable for "Quick" prototype
    // But we might want to prevent massive BMPs?
    // Let's stick to default contenteditable behavior for MVP. 
    // It automatically handles formatting and images as Base64.
  });

  toggleSidebarBtn.addEventListener('click', () => {
    sidebar.classList.toggle('open');
    sidebar.classList.toggle('closed');
  });
  
  searchNotes.addEventListener('input', (e) => {
    const term = e.target.value.toLowerCase();
    renderNoteList(allNotesCache.filter(n => {
      const title = getTitleFromContent(n.content).toLowerCase();
      return title.includes(term);
    }));
  });

  // Functions
  async function refreshNoteList() {
    allNotesCache = await getAllNotes();
    renderNoteList(allNotesCache);
  }

  function getTitleFromContent(html) {
    // Extract first line or some text
    const temp = document.createElement('div');
    temp.innerHTML = html;
    const text = temp.textContent.trim();
    if (!text) return 'ç„¡æ¨™é¡Œç­†è¨˜';
    return text.length > 20 ? text.substring(0, 20) + '...' : text;
  }

  function renderNoteList(notes) {
    noteList.innerHTML = '';
    
    if (notes.length === 0) {
      noteList.innerHTML = '<div class="p-3 text-muted text-center small">æ²’æœ‰ç­†è¨˜</div>';
      return;
    }

    notes.forEach(note => {
      const title = getTitleFromContent(note.content);
      const date = new Date(note.updatedAt).toLocaleDateString();
      
      const item = document.createElement('a');
      item.href = '#';
      item.className = `list-group-item list-group-item-action note-item ${note.id === currentNoteId ? 'active' : ''} d-flex justify-content-between align-items-center`;
      item.onclick = (e) => {
        e.preventDefault();
        // If clicking delete button, don't load
        if (e.target.closest('.delete-btn')) return;
        
        loadNote(note.id, note);
        // On mobile, close sidebar
        if (window.innerWidth <= 768) {
            sidebar.classList.remove('open');
            sidebar.classList.add('closed');
        }
      };

      item.innerHTML = `
        <div class="text-truncate">
          <div class="fw-bold text-truncate">${title}</div>
          <small class="text-muted">${date}</small>
        </div>
        <button class="btn btn-sm btn-link text-danger delete-btn p-0 ms-2" title="åˆªé™¤">
          ğŸ—‘ï¸
        </button>
      `;
      
      // Delete handler
      const delBtn = item.querySelector('.delete-btn');
      delBtn.onclick = async (e) => {
        e.stopPropagation(); // prevent loading
        if (confirm('ç¢ºå®šè¦åˆªé™¤é€™å‰‡ç­†è¨˜å—ï¼Ÿ')) {
          await deleteNoteFromDB(note.id);
          await refreshNoteList();
          if (currentNoteId === note.id) {
            // Deleted current note
            if (allNotesCache.length > 0) {
              loadNote(allNotesCache[0].id, allNotesCache[0]);
            } else {
              createNewNote(false);
            }
          }
        }
      };

      noteList.appendChild(item);
    });
  }

  async function createNewNote(shouldSave = true) {
    // If current was modified but not saved? (handled by debouncer usually)
    // Force save current if pending?
    if (saveTimeout) {
      clearTimeout(saveTimeout);
      await performSave();
    }

    currentNoteId = 'note_' + Date.now();
    editor.innerHTML = '';
    
    // Update active state in list
    document.querySelectorAll('.note-item').forEach(el => el.classList.remove('active'));
    
    if (shouldSave) {
      await performSave(); // initial save
      await refreshNoteList();
    }
    
    editor.focus();
  }

  async function loadNote(id, noteObj = null) {
    if (saveTimeout) {
      clearTimeout(saveTimeout);
      await performSave();
    }
    
    currentNoteId = id;
    
    // If noteObj provided, use it, else fetch? (We usually have it from list)
    if (noteObj) {
      editor.innerHTML = noteObj.content;
    } else {
       // Should fetch from DB if deep linking (future)
    }

    // Update active UI
    document.querySelectorAll('.note-item').forEach(el => el.classList.remove('active'));
    // Find in list
    // Re-render list to ensure active class is correct if we just switched
    // Actually simpler to just re-render or manual add class. 
    // Let's just re-render to be safe and simple
    renderNoteList(allNotesCache);
  }

  async function performSave() {
    if (!currentNoteId) return;

    const content = editor.innerHTML;
    const note = {
      id: currentNoteId,
      content: content,
      updatedAt: Date.now()
    };

    try {
      await saveNote(note);
      
      // UI Feedback
      saveStatus.classList.remove('opacity-0');
      saveStatus.classList.add('opacity-100');
      setTimeout(() => {
        saveStatus.classList.remove('opacity-100');
        saveStatus.classList.add('opacity-0');
      }, 2000);

      // Refresh list to update titles/ordering
      await refreshNoteList();
    } catch (e) {
      console.error("Save failed", e);
    }
  }
</script>
