---
import BaseLayout from '@/layouts/BaseLayout.astro';
import Navbar from '@/components/Navbar.astro';
---
<BaseLayout
  title="æ‰‹å¯«æ•¸å­—è¾¨è­˜ | æŒ«å±å‹‡çš„å¯¦ç”¨å·¥å…·"
  description="åœ¨ç•«å¸ƒä¸Šæ‰‹å¯«æ•¸å­—ï¼ŒAI å³æ™‚è¾¨è­˜ï¼ä½¿ç”¨ TensorFlow.js åœ¨ç€è¦½å™¨ç«¯é‹è¡Œæ·±åº¦å­¸ç¿’æ¨¡å‹ï¼Œæ”¯æ´æ‰‹æ©Ÿèˆ‡é›»è…¦ã€‚"
>
  <Navbar currentPage="tools" />

  <div class="container mt-4">
    <h1 class="mb-3">âœï¸ æ‰‹å¯«æ•¸å­—è¾¨è­˜</h1>

    <!-- åŠŸèƒ½èªªæ˜ -->
    <div class="alert alert-info border-0 shadow-sm mb-4">
      <h5 class="alert-heading fw-bold">ğŸ§  AI åœ¨ä½ çš„ç€è¦½å™¨è£¡é‹è¡Œ</h5>
      <p class="mb-0">
        ä½¿ç”¨æ·±åº¦å­¸ç¿’æ¨¡å‹è¾¨è­˜æ‰‹å¯«æ•¸å­—ï¼Œ<strong>ä¸éœ€è¦ç¶²è·¯é€£ç·š</strong>ï¼Œæ‰€æœ‰é‹ç®—éƒ½åœ¨æœ¬åœ°å®Œæˆã€‚
      </p>
    </div>

    <div class="row">
      <!-- å·¦å´ï¼šç•«å¸ƒå€åŸŸ -->
      <div class="col-lg-6 mb-4">
        <div class="card">
          <div class="card-header d-flex justify-content-between align-items-center">
            <span><span class="step-badge">1</span> åœ¨ä¸‹æ–¹ç•«ä¸€å€‹æ•¸å­— (0-9)</span>
            <button id="clearBtn" class="btn btn-sm btn-outline-secondary">æ¸…é™¤</button>
          </div>
          <div class="card-body text-center">
            <div class="canvas-wrapper">
              <canvas id="drawCanvas" width="280" height="280"></canvas>
            </div>
            <p class="text-muted small mt-2 mb-0">ç”¨æ»‘é¼ æˆ–æ‰‹æŒ‡åœ¨ç•«å¸ƒä¸Šæ›¸å¯«</p>
          </div>
        </div>

        <!-- é è™•ç†é è¦½ -->
        <div class="card mt-3">
          <div class="card-header">
            <span class="step-badge">2</span> æ¨¡å‹è¦–è§’
          </div>
          <div class="card-body">
            <div class="preview-row">
              <div class="preview-item">
                <canvas id="previewCanvas" width="140" height="140" class="preview-canvas"></canvas>
                <p class="text-muted small mt-2 mb-0">è¼¸å…¥åœ–ç‰‡ (28Ã—28)</p>
              </div>
              <div class="preview-item">
                <canvas id="saliencyCanvas" width="140" height="140" class="preview-canvas"></canvas>
                <p class="text-muted small mt-2 mb-0">Saliency Map</p>
              </div>
            </div>
            <p class="text-muted small mt-3 mb-0 text-center">
              <span class="saliency-legend high">ç´…</span> = é«˜å½±éŸ¿ &nbsp;
              <span class="saliency-legend low">è—</span> = ä½å½±éŸ¿
            </p>
          </div>
        </div>
      </div>

      <!-- å³å´ï¼šé æ¸¬çµæœ -->
      <div class="col-lg-6 mb-4">
        <div class="card h-100">
          <div class="card-header">
            <span class="step-badge">3</span> é æ¸¬çµæœ
          </div>
          <div class="card-body">
            <!-- æ¨¡å‹è¼‰å…¥ç‹€æ…‹ -->
            <div id="modelStatus" class="text-center py-4">
              <div class="spinner-border text-primary mb-3" role="status">
                <span class="visually-hidden">è¼‰å…¥ä¸­...</span>
              </div>
              <p class="text-muted mb-0">æ­£åœ¨è¼‰å…¥æ¨¡å‹...</p>
            </div>

            <!-- é æ¸¬æ•¸å­— -->
            <div id="predictionResult" class="d-none">
              <div class="text-center mb-4">
                <div class="predicted-digit" id="predictedDigit">?</div>
                <p class="text-muted mb-0">é æ¸¬æ•¸å­—</p>
              </div>

              <!-- æ©Ÿç‡é•·æ¢åœ– -->
              <div class="probability-chart" id="probabilityChart">
                <!-- å‹•æ…‹ç”Ÿæˆ -->
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- æŠ€è¡“èªªæ˜ -->
    <div class="card mt-2 mb-4">
      <div class="card-header d-flex justify-content-between align-items-center">
        <span><span class="step-badge">?</span> é€™æ˜¯æ€éº¼é‹ä½œçš„ï¼Ÿ</span>
        <a href="/blog/mnist-browser-ml/" class="btn btn-sm btn-outline-primary">é–±è®€é–‹ç™¼ç­†è¨˜</a>
      </div>
      <div class="card-body">
        <div class="row">
          <div class="col-md-3 mb-3 mb-md-0">
            <h6>æ¨¡å‹æ¶æ§‹</h6>
            <p class="small text-muted mb-0">
              è¼•é‡ç´š CNNï¼Œ2 å±¤å·ç© + 1 å±¤å…¨é€£æ¥ï¼ŒMNIST æº–ç¢ºåº¦ 98.77%ã€‚
            </p>
          </div>
          <div class="col-md-3 mb-3 mb-md-0">
            <h6>å‰ç«¯æ¨ç†</h6>
            <p class="small text-muted mb-0">
              TensorFlow.js è¼‰å…¥æ¨¡å‹ï¼Œç€è¦½å™¨ç«¯é‹ç®—ï¼Œç´„ 420KBã€‚
            </p>
          </div>
          <div class="col-md-3 mb-3 mb-md-0">
            <h6>åœ–ç‰‡é è™•ç†</h6>
            <p class="small text-muted mb-0">
              ç­†è·¡ç½®ä¸­ã€ç¸®æ”¾ 28Ã—28ã€æ­£è¦åŒ–ç‚ºé»‘åº•ç™½å­—ã€‚
            </p>
          </div>
          <div class="col-md-3">
            <h6>Saliency Map</h6>
            <p class="small text-muted mb-0">
              è¨ˆç®—è¼¸å…¥æ¢¯åº¦ï¼Œé¡¯ç¤ºå“ªäº›åƒç´ å°é æ¸¬å½±éŸ¿æœ€å¤§ã€‚
            </p>
          </div>
        </div>
      </div>
    </div>
  </div>
</BaseLayout>

<style>
  /* Canvas æ¨£å¼ */
  .canvas-wrapper {
    display: inline-block;
    border: 3px solid var(--bs-primary);
    border-radius: 1rem;
    overflow: hidden;
    touch-action: none; /* é˜²æ­¢æ‰‹æ©Ÿæ»‘å‹• */
  }

  #drawCanvas {
    display: block;
    background: #1a1a2e;
    cursor: crosshair;
  }

  .preview-canvas {
    border: 2px solid var(--bs-secondary);
    border-radius: 0.5rem;
    image-rendering: pixelated;
    background: #000;
  }

  .preview-row {
    display: flex;
    justify-content: center;
    gap: 1.5rem;
    flex-wrap: wrap;
  }

  .preview-item {
    text-align: center;
  }

  .saliency-legend {
    display: inline-block;
    padding: 0.1rem 0.4rem;
    border-radius: 0.25rem;
    font-weight: bold;
    font-size: 0.75rem;
  }

  .saliency-legend.high {
    background: rgba(255, 0, 0, 0.3);
    color: #ff6b6b;
  }

  .saliency-legend.low {
    background: rgba(0, 0, 255, 0.3);
    color: #6b9bff;
  }

  /* Step badge */
  .step-badge {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 1.5rem;
    height: 1.5rem;
    border-radius: 50%;
    background: var(--bs-primary);
    color: white;
    font-size: 0.8rem;
    font-weight: bold;
    margin-right: 0.5rem;
  }

  /* é æ¸¬æ•¸å­—é¡¯ç¤º */
  .predicted-digit {
    font-size: 5rem;
    font-weight: bold;
    line-height: 1;
    color: var(--bs-primary);
    text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
  }

  /* æ©Ÿç‡é•·æ¢åœ– */
  .probability-chart {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .prob-row {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .prob-label {
    width: 1.5rem;
    text-align: center;
    font-weight: bold;
    font-size: 0.9rem;
  }

  .prob-bar-wrapper {
    flex: 1;
    height: 1.2rem;
    background: rgba(255,255,255,0.1);
    border-radius: 0.25rem;
    overflow: hidden;
  }

  .prob-bar {
    height: 100%;
    background: var(--bs-primary);
    border-radius: 0.25rem;
    transition: width 0.3s ease;
  }

  .prob-bar.top-prediction {
    background: var(--bs-success);
  }

  .prob-value {
    width: 3.5rem;
    text-align: right;
    font-size: 0.8rem;
    font-family: monospace;
  }
</style>

<script is:inline src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.17.0/dist/tf.min.js"></script>
<script is:inline>
document.addEventListener('DOMContentLoaded', async function() {
  // ===== DOM Elements =====
  const drawCanvas = document.getElementById('drawCanvas');
  const drawCtx = drawCanvas.getContext('2d');
  const previewCanvas = document.getElementById('previewCanvas');
  const previewCtx = previewCanvas.getContext('2d');
  const saliencyCanvas = document.getElementById('saliencyCanvas');
  const saliencyCtx = saliencyCanvas.getContext('2d');
  const clearBtn = document.getElementById('clearBtn');
  const modelStatus = document.getElementById('modelStatus');
  const predictionResult = document.getElementById('predictionResult');
  const predictedDigit = document.getElementById('predictedDigit');
  const probabilityChart = document.getElementById('probabilityChart');

  // ===== State =====
  let isDrawing = false;
  let model = null;
  let lastX = 0;
  let lastY = 0;

  // ===== Initialize Canvas =====
  function initCanvas() {
    drawCtx.fillStyle = '#1a1a2e';
    drawCtx.fillRect(0, 0, drawCanvas.width, drawCanvas.height);
    drawCtx.strokeStyle = '#ffffff';
    drawCtx.lineWidth = 15;
    drawCtx.lineCap = 'round';
    drawCtx.lineJoin = 'round';
  }
  initCanvas();

  // ===== Load Model =====
  try {
    model = await tf.loadLayersModel('/models/mnist/model.json');
    modelStatus.classList.add('d-none');
    predictionResult.classList.remove('d-none');
    initProbabilityChart();
    console.log('Model loaded successfully');
  } catch (error) {
    console.error('Failed to load model:', error);
    modelStatus.innerHTML = `
      <p class="text-danger mb-0">æ¨¡å‹è¼‰å…¥å¤±æ•—</p>
      <p class="text-muted small mt-2">${error.message}</p>
    `;
  }

  // ===== Drawing Functions =====
  function getPosition(e) {
    const rect = drawCanvas.getBoundingClientRect();
    const scaleX = drawCanvas.width / rect.width;
    const scaleY = drawCanvas.height / rect.height;

    if (e.touches) {
      return {
        x: (e.touches[0].clientX - rect.left) * scaleX,
        y: (e.touches[0].clientY - rect.top) * scaleY
      };
    }
    return {
      x: (e.clientX - rect.left) * scaleX,
      y: (e.clientY - rect.top) * scaleY
    };
  }

  function startDrawing(e) {
    e.preventDefault();
    isDrawing = true;
    const pos = getPosition(e);
    lastX = pos.x;
    lastY = pos.y;
  }

  function draw(e) {
    if (!isDrawing) return;
    e.preventDefault();

    const pos = getPosition(e);
    drawCtx.beginPath();
    drawCtx.moveTo(lastX, lastY);
    drawCtx.lineTo(pos.x, pos.y);
    drawCtx.stroke();

    lastX = pos.x;
    lastY = pos.y;
  }

  function stopDrawing(e) {
    if (!isDrawing) return;
    isDrawing = false;
    predict();
  }

  // Mouse events
  drawCanvas.addEventListener('mousedown', startDrawing);
  drawCanvas.addEventListener('mousemove', draw);
  drawCanvas.addEventListener('mouseup', stopDrawing);
  drawCanvas.addEventListener('mouseleave', stopDrawing);

  // Touch events
  drawCanvas.addEventListener('touchstart', startDrawing, { passive: false });
  drawCanvas.addEventListener('touchmove', draw, { passive: false });
  drawCanvas.addEventListener('touchend', stopDrawing);

  // Clear button
  clearBtn.addEventListener('click', () => {
    initCanvas();
    clearPreview();
    resetPrediction();
  });

  // ===== Preview & Preprocessing =====
  function clearPreview() {
    previewCtx.fillStyle = '#000';
    previewCtx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
    saliencyCtx.fillStyle = '#000';
    saliencyCtx.fillRect(0, 0, saliencyCanvas.width, saliencyCanvas.height);
  }
  clearPreview();

  function preprocessImage() {
    // å–å¾—åŸå§‹ç•«å¸ƒæ•¸æ“š
    const imageData = drawCtx.getImageData(0, 0, drawCanvas.width, drawCanvas.height);
    const data = imageData.data;

    // æ‰¾å‡ºç­†è·¡çš„é‚Šç•Œæ¡†
    let minX = drawCanvas.width, minY = drawCanvas.height, maxX = 0, maxY = 0;
    let hasContent = false;

    for (let y = 0; y < drawCanvas.height; y++) {
      for (let x = 0; x < drawCanvas.width; x++) {
        const idx = (y * drawCanvas.width + x) * 4;
        // æª¢æŸ¥æ˜¯å¦ç‚ºç™½è‰²ç­†è·¡ï¼ˆR > 200ï¼‰
        if (data[idx] > 200) {
          hasContent = true;
          if (x < minX) minX = x;
          if (x > maxX) maxX = x;
          if (y < minY) minY = y;
          if (y > maxY) maxY = y;
        }
      }
    }

    if (!hasContent) return null;

    // åŠ ä¸Šé‚Šè·
    const padding = 20;
    minX = Math.max(0, minX - padding);
    minY = Math.max(0, minY - padding);
    maxX = Math.min(drawCanvas.width, maxX + padding);
    maxY = Math.min(drawCanvas.height, maxY + padding);

    // è¨ˆç®—é‚Šç•Œæ¡†å¤§å°ï¼Œä¿æŒæ­£æ–¹å½¢
    const bboxWidth = maxX - minX;
    const bboxHeight = maxY - minY;
    const size = Math.max(bboxWidth, bboxHeight);

    // å±…ä¸­åç§»
    const offsetX = minX - (size - bboxWidth) / 2;
    const offsetY = minY - (size - bboxHeight) / 2;

    // å»ºç«‹è‡¨æ™‚ç•«å¸ƒç”¨æ–¼è£åˆ‡å’Œç¸®æ”¾
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = 28;
    tempCanvas.height = 28;
    const tempCtx = tempCanvas.getContext('2d');

    // é»‘è‰²èƒŒæ™¯
    tempCtx.fillStyle = '#000';
    tempCtx.fillRect(0, 0, 28, 28);

    // ç¸®æ”¾ä¸¦ç¹ªè£½ï¼ˆMNIST ä½¿ç”¨ 20x20 çš„å…§å®¹å€åŸŸï¼Œå‘¨åœ 4px é‚Šè·ï¼‰
    const scale = 20 / size;
    tempCtx.drawImage(
      drawCanvas,
      offsetX, offsetY, size, size,
      4, 4, 20, 20
    );

    // æ›´æ–°é è¦½ç•«å¸ƒï¼ˆæ”¾å¤§é¡¯ç¤ºï¼‰
    previewCtx.imageSmoothingEnabled = false;
    previewCtx.drawImage(tempCanvas, 0, 0, 140, 140);

    // å–å¾— 28x28 ç°éšæ•¸æ“š
    const smallImageData = tempCtx.getImageData(0, 0, 28, 28);
    const pixels = new Float32Array(28 * 28);

    for (let i = 0; i < 28 * 28; i++) {
      // å– R é€šé“å€¼ä¸¦æ­£è¦åŒ–åˆ° 0-1
      pixels[i] = smallImageData.data[i * 4] / 255.0;
    }

    return pixels;
  }

  // ===== Prediction =====
  function initProbabilityChart() {
    let html = '';
    for (let i = 0; i < 10; i++) {
      html += `
        <div class="prob-row">
          <span class="prob-label">${i}</span>
          <div class="prob-bar-wrapper">
            <div class="prob-bar" id="bar-${i}" style="width: 0%"></div>
          </div>
          <span class="prob-value" id="prob-${i}">0.0%</span>
        </div>
      `;
    }
    probabilityChart.innerHTML = html;
  }

  function resetPrediction() {
    predictedDigit.textContent = '?';
    for (let i = 0; i < 10; i++) {
      const bar = document.getElementById(`bar-${i}`);
      const prob = document.getElementById(`prob-${i}`);
      bar.style.width = '0%';
      bar.classList.remove('top-prediction');
      prob.textContent = '0.0%';
    }
  }

  // ===== Saliency Map =====
  function renderSaliencyMap(gradients) {
    // å–çµ•å°å€¼ä¸¦æ‰¾æœ€å¤§å€¼ç”¨æ–¼æ­£è¦åŒ–
    const absGradients = gradients.map(Math.abs);
    const maxGrad = Math.max(...absGradients);

    if (maxGrad === 0) return;

    // å»ºç«‹ 28x28 ImageData
    const imageData = saliencyCtx.createImageData(28, 28);

    for (let i = 0; i < 28 * 28; i++) {
      const normalized = absGradients[i] / maxGrad;

      // ä½¿ç”¨è—-ç´…è‰²éšï¼ˆä½å½±éŸ¿=è—ï¼Œé«˜å½±éŸ¿=ç´…ï¼‰
      let r, g, b;
      if (normalized < 0.5) {
        // è—åˆ°ç™½
        const t = normalized * 2;
        r = Math.floor(t * 255);
        g = Math.floor(t * 255);
        b = 255;
      } else {
        // ç™½åˆ°ç´…
        const t = (normalized - 0.5) * 2;
        r = 255;
        g = Math.floor((1 - t) * 255);
        b = Math.floor((1 - t) * 255);
      }

      imageData.data[i * 4] = r;
      imageData.data[i * 4 + 1] = g;
      imageData.data[i * 4 + 2] = b;
      imageData.data[i * 4 + 3] = 255;
    }

    // ç¹ªè£½åˆ°è‡¨æ™‚ canvas å†æ”¾å¤§
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = 28;
    tempCanvas.height = 28;
    const tempCtx = tempCanvas.getContext('2d');
    tempCtx.putImageData(imageData, 0, 0);

    // æ”¾å¤§é¡¯ç¤º
    saliencyCtx.imageSmoothingEnabled = false;
    saliencyCtx.drawImage(tempCanvas, 0, 0, 140, 140);
  }

  async function predict() {
    if (!model) return;

    const pixels = preprocessImage();
    if (!pixels) {
      resetPrediction();
      return;
    }

    // å»ºç«‹ tensor: [1, 28, 28, 1]
    const input = tf.tensor4d(pixels, [1, 28, 28, 1]);

    // æ¨ç†
    const prediction = model.predict(input);
    const probabilities = await prediction.data();

    // æ‰¾å‡ºæœ€é«˜æ©Ÿç‡çš„æ•¸å­—
    let maxProb = 0;
    let maxIdx = 0;
    for (let i = 0; i < 10; i++) {
      if (probabilities[i] > maxProb) {
        maxProb = probabilities[i];
        maxIdx = i;
      }
    }

    // è¨ˆç®— Saliency Mapï¼ˆå°é æ¸¬é¡åˆ¥çš„æ¢¯åº¦ï¼‰
    const gradientFunc = tf.grad(x => {
      const pred = model.predict(x);
      // å–é æ¸¬é¡åˆ¥çš„ logit
      return pred.gather([maxIdx], 1).squeeze();
    });

    const gradients = gradientFunc(input);
    const gradData = await gradients.data();

    // æ¸²æŸ“ Saliency Map
    renderSaliencyMap(Array.from(gradData));

    // é‡‹æ”¾ tensor
    input.dispose();
    prediction.dispose();
    gradients.dispose();

    // æ›´æ–° UI
    predictedDigit.textContent = maxIdx;

    for (let i = 0; i < 10; i++) {
      const bar = document.getElementById(`bar-${i}`);
      const prob = document.getElementById(`prob-${i}`);
      const percentage = probabilities[i] * 100;

      bar.style.width = `${percentage}%`;
      prob.textContent = `${percentage.toFixed(1)}%`;

      if (i === maxIdx) {
        bar.classList.add('top-prediction');
      } else {
        bar.classList.remove('top-prediction');
      }
    }
  }
});
</script>
