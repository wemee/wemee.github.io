---
import BaseLayout from '@/layouts/BaseLayout.astro';
import Navbar from '@/components/Navbar.astro';
---
<BaseLayout 
  title="æ‰“ç£šå¡Š | æŒ«å±å‹‡çš„éŠæˆ²é–“" 
  description="ç¶“å…¸å¾©å¤çš„æ‰“ç£šå¡ŠéŠæˆ²ï¼ŒæŒ‘æˆ°åæ‡‰ç¥ç¶“ï¼å…§å«è¶…å¼· AI è‡ªå‹•éŠç©æ¨¡å¼ (AI æ¨¡å¼)ï¼Œä¾†çœ‹çœ‹æ¼”ç®—æ³•æ˜¯æ€éº¼éé—œçš„ã€‚"
>
  <Navbar currentPage="game" />
  <div class="container-fluid mt-3">
    <div class="row justify-content-center">
      <div class="col-auto">
        <div class="game-container">
          <canvas id="gameCanvas" width="480" height="600"></canvas>
          <div class="game-overlay" id="startScreen">
            <h2>ğŸ§± æ‰“ç£šå¡Š</h2>
            <p>æ‰“ç ´æ‰€æœ‰ç£šå¡Šï¼</p>
            <button class="btn btn-lg btn-primary" id="startBtn">é–‹å§‹éŠæˆ²</button>
            <button class="btn btn-lg btn-warning mt-2" id="aiStartBtn">ğŸ¤– AI æ¨¡å¼</button>
            <div class="controls-info mt-3">
              <small>â† â†’ æˆ– æ»‘é¼ ç§»å‹•æ¿å­<br>ç©ºç™½éµæˆ–é»æ“Šç™¼çƒ</small>
            </div>
          </div>
          <div class="game-overlay hidden" id="winScreen">
            <h2>ğŸ‰ æ­å–œéé—œï¼</h2>
            <p>åˆ†æ•¸: <span id="winScore">0</span></p>
            <button class="btn btn-lg btn-success" id="nextLevelBtn">ä¸‹ä¸€é—œ</button>
          </div>
          <div class="game-overlay hidden" id="gameOverScreen">
            <h2>ğŸ’€ éŠæˆ²çµæŸ</h2>
            <p>æœ€çµ‚åˆ†æ•¸: <span id="finalScore">0</span></p>
            <button class="btn btn-lg btn-primary" id="restartBtn">å†ç©ä¸€æ¬¡</button>
          </div>
          <div class="game-hud">
            <span class="hud-item">åˆ†æ•¸: <span id="scoreDisplay">0</span></span>
            <span class="hud-item"><span id="aiIndicator" class="hidden">ğŸ¤– AI</span> ç”Ÿå‘½: <span id="livesDisplay">â¤ï¸â¤ï¸â¤ï¸</span></span>
            <span class="hud-item">é—œå¡: <span id="levelDisplay">1</span></span>
          </div>
        </div>
        <div class="text-center mt-3">
          <a href="/game/" class="btn btn-outline-secondary">â† è¿”å›éŠæˆ²åˆ—è¡¨</a>
        </div>
      </div>
    </div>
  </div>
</BaseLayout>

<style>
  .game-container {
    position: relative;
    display: inline-block;
  }
  
  #gameCanvas {
    display: block;
    border-radius: 12px;
    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
  }
  
  .game-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.85);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    color: white;
    border-radius: 12px;
    text-align: center;
    padding: 20px;
  }
  
  .game-overlay.hidden {
    display: none;
  }
  
  .game-overlay h2 {
    font-size: 2.5rem;
    margin-bottom: 1rem;
  }
  
  .controls-info {
    color: #aaa;
  }
  
  .game-hud {
    display: flex;
    justify-content: space-between;
    padding: 10px 15px;
    background: linear-gradient(135deg, #1a1a2e, #16213e);
    border-radius: 0 0 12px 12px;
    color: white;
    font-size: 14px;
  }
  
  .hud-item {
    font-weight: bold;
  }
</style>

<script>
  interface Brick {
    x: number;
    y: number;
    width: number;
    height: number;
    color: string;
    hits: number;
    maxHits: number;
    points: number;
  }

  interface Particle {
    x: number;
    y: number;
    vx: number;
    vy: number;
    life: number;
    color: string;
    size: number;
  }

  interface PowerUp {
    x: number;
    y: number;
    type: 'wide' | 'multi' | 'slow';
    color: string;
  }

  class BreakoutGame {
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D;
    
    // éŠæˆ²ç‰©ä»¶
    private ball = { x: 240, y: 450, radius: 8, dx: 0, dy: 0, speed: 7 };
    
    // é€Ÿåº¦è¨­å®š
    private readonly MIN_SPEED = 7;
    private readonly MAX_SPEED = 14;
    private readonly AI_MIN_SPEED = 10;  // AI æ¨¡å¼åˆå§‹é€Ÿåº¦æ›´å¿«
    private readonly AI_MAX_SPEED = 18;
    private readonly SPEED_INCREMENT = 0.15;
    private paddle = { x: 190, y: 560, width: 100, height: 12 };
    private bricks: Brick[] = [];
    private particles: Particle[] = [];
    private powerUps: PowerUp[] = [];
    
    // ç‹€æ…‹
    private score = 0;
    private lives = 3;
    private level = 1;
    private gameState: 'start' | 'ready' | 'playing' | 'win' | 'gameover' = 'start';
    private ballLaunched = false;
    
    // æŒçºŒæŒ‰éµç‹€æ…‹
    private keys = { left: false, right: false };
    private readonly PADDLE_SPEED = 10;
    
    // AI æ¨¡å¼
    private aiMode = false;
    private readonly AI_PADDLE_SPEED = 12;

    // é¡è‰²æ–¹æ¡ˆ
    private readonly COLORS = [
      '#ff6b6b', '#feca57', '#48dbfb', '#1dd1a1', '#ff9ff3', '#54a0ff'
    ];

    constructor() {
      this.canvas = document.getElementById('gameCanvas') as HTMLCanvasElement;
      this.ctx = this.canvas.getContext('2d')!;
      
      this.bindEvents();
      this.gameLoop();
    }

    private createBricks() {
      this.bricks = [];
      const rows = 4 + Math.min(this.level, 4);
      const cols = 8;
      const brickWidth = 52;
      const brickHeight = 20;
      const padding = 6;
      const offsetX = 12;
      const offsetY = 50;

      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const maxHits = row < 2 && this.level > 1 ? 2 : 1;
          this.bricks.push({
            x: offsetX + col * (brickWidth + padding),
            y: offsetY + row * (brickHeight + padding),
            width: brickWidth,
            height: brickHeight,
            color: this.COLORS[row % this.COLORS.length],
            hits: 0,
            maxHits: maxHits,
            points: (rows - row) * 10 * maxHits
          });
        }
      }
    }

    private initGame() {
      this.paddle = { x: this.canvas.width / 2 - 50, y: 560, width: 100, height: 12 };
      this.particles = [];
      this.powerUps = [];
      this.ballLaunched = false;
      this.createBricks();
      this.resetBall();
    }

    private resetBall() {
      this.ballLaunched = false;
      this.ball.x = this.paddle.x + this.paddle.width / 2;
      this.ball.y = this.paddle.y - this.ball.radius - 2;
      this.ball.dx = 0;
      this.ball.dy = 0;
      
      // AI æ¨¡å¼çƒé€Ÿæ›´å¿«
      const baseSpeed = this.aiMode ? this.AI_MIN_SPEED : this.MIN_SPEED;
      this.ball.speed = baseSpeed + this.level * 0.5;
    }

    private launchBall() {
      if (this.ballLaunched) return;
      this.ballLaunched = true;
      const angle = (Math.random() - 0.5) * Math.PI * 0.5; // -45 åˆ° 45 åº¦
      this.ball.dx = this.ball.speed * Math.sin(angle);
      this.ball.dy = -this.ball.speed * Math.cos(angle);
    }

    private bindEvents() {
      document.getElementById('startBtn')?.addEventListener('click', () => this.startGame(false));
      document.getElementById('aiStartBtn')?.addEventListener('click', () => this.startGame(true));
      document.getElementById('restartBtn')?.addEventListener('click', () => {
        this.level = 1;
        this.score = 0;
        this.lives = 3;
        this.startGame(this.aiMode);
      });
      document.getElementById('nextLevelBtn')?.addEventListener('click', () => {
        this.level++;
        this.lives = Math.min(this.lives + 1, 5);
        this.startGame(this.aiMode);
      });

      // éµç›¤æ§åˆ¶ - æŒçºŒç§»å‹•
      document.addEventListener('keydown', (e) => {
        if (this.gameState !== 'ready' && this.gameState !== 'playing') return;
        
        if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
          this.keys.left = true;
        }
        if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
          this.keys.right = true;
        }
        if (e.key === ' ') {
          e.preventDefault();
          if (!this.ballLaunched) {
            this.launchBall();
            this.gameState = 'playing';
          }
        }
      });

      document.addEventListener('keyup', (e) => {
        if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
          this.keys.left = false;
        }
        if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
          this.keys.right = false;
        }
      });

      // æ»‘é¼ æ§åˆ¶
      this.canvas.addEventListener('mousemove', (e) => {
        if (this.gameState !== 'ready' && this.gameState !== 'playing') return;
        const rect = this.canvas.getBoundingClientRect();
        const scaleX = this.canvas.width / rect.width;
        this.paddle.x = (e.clientX - rect.left) * scaleX - this.paddle.width / 2;
        this.paddle.x = Math.max(0, Math.min(this.paddle.x, this.canvas.width - this.paddle.width));
      });

      // æ»‘é¼ é»æ“Šç™¼çƒ
      this.canvas.addEventListener('click', () => {
        if ((this.gameState === 'ready' || this.gameState === 'playing') && !this.ballLaunched) {
          this.launchBall();
          this.gameState = 'playing';
        }
      });

      // è§¸æ§æ§åˆ¶
      this.canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (this.gameState !== 'ready' && this.gameState !== 'playing') return;
        const rect = this.canvas.getBoundingClientRect();
        const scaleX = this.canvas.width / rect.width;
        this.paddle.x = (e.touches[0].clientX - rect.left) * scaleX - this.paddle.width / 2;
        this.paddle.x = Math.max(0, Math.min(this.paddle.x, this.canvas.width - this.paddle.width));
      });

      // è§¸æ§é»æ“Šç™¼çƒ
      this.canvas.addEventListener('touchstart', () => {
        if ((this.gameState === 'ready' || this.gameState === 'playing') && !this.ballLaunched) {
          this.launchBall();
          this.gameState = 'playing';
        }
      });
    }

    private startGame(enableAI: boolean = false) {
      this.aiMode = enableAI;
      this.initGame();
      this.gameState = 'ready';
      this.hideOverlay('startScreen');
      this.hideOverlay('gameOverScreen');
      this.hideOverlay('winScreen');
      this.updateHUD();
      
      // é¡¯ç¤º/éš±è— AI æŒ‡ç¤ºå™¨
      const aiIndicator = document.getElementById('aiIndicator');
      if (aiIndicator) {
        aiIndicator.classList.toggle('hidden', !this.aiMode);
      }
      
      // AI æ¨¡å¼è‡ªå‹•ç™¼çƒ
      if (this.aiMode) {
        setTimeout(() => {
          this.launchBall();
          this.gameState = 'playing';
        }, 500);
      }
    }

    // === AI é‚è¼¯ ===
    private predictBallX(): number {
      // é æ¸¬çƒè½åˆ°æ¿å­é«˜åº¦æ™‚çš„ x ä½ç½®
      if (this.ball.dy <= 0) {
        // çƒå¾€ä¸Šï¼Œæš«æ™‚ç„¡æ³•é æ¸¬ï¼Œå›å‚³ç›®å‰çƒçš„ x
        return this.ball.x;
      }
      
      let simX = this.ball.x;
      let simY = this.ball.y;
      let simDx = this.ball.dx;
      const simDy = this.ball.dy;
      
      // æ¨¡æ“¬çƒçš„è»Œè·¡ç›´åˆ°åˆ°é”æ¿å­é«˜åº¦
      while (simY < this.paddle.y - this.ball.radius) {
        simX += simDx;
        simY += simDy;
        
        // ç‰†å£åå½ˆ
        if (simX - this.ball.radius < 0) {
          simX = this.ball.radius;
          simDx = Math.abs(simDx);
        }
        if (simX + this.ball.radius > this.canvas.width) {
          simX = this.canvas.width - this.ball.radius;
          simDx = -Math.abs(simDx);
        }
        
        // é˜²æ­¢ç„¡é™è¿´åœˆ
        if (simY > this.canvas.height + 100) break;
      }
      
      return simX;
    }

    private findBestPowerUp(): PowerUp | null {
      // æ‰¾å‡ºæœ€æ¥è¿‘ä¸”å¯æ¥åˆ°çš„é“å…·
      let bestPU: PowerUp | null = null;
      let bestScore = -Infinity;
      
      for (const pu of this.powerUps) {
        // é æ¸¬é“å…·è½ä¸‹æ™‚çš„ä½ç½®
        const timeToReach = (this.paddle.y - pu.y) / 2; // é“å…·é€Ÿåº¦ç‚º 2
        if (timeToReach <= 0) continue;
        
        const puX = pu.x;
        const distFromPaddle = Math.abs(puX - (this.paddle.x + this.paddle.width / 2));
        
        // åªè€ƒæ…®æœ‰æ©Ÿæœƒæ¥åˆ°çš„é“å…·
        if (distFromPaddle < 150 && pu.y > 100) {
          const score = pu.y - distFromPaddle * 0.5; // è¶Šè¿‘ã€è¶Šå¿«è½ä¸‹çš„è¶Šå„ªå…ˆ
          if (score > bestScore) {
            bestScore = score;
            bestPU = pu;
          }
        }
      }
      
      return bestPU;
    }

    private findBestHitPosition(): number | null {
      // æ‰¾å‡ºèƒ½æ‰“åˆ°æœ€å¤šç£šå¡Šçš„ä½ç½®
      // ç°¡åŒ–ç‰ˆï¼šæ‰¾å‡ºç£šå¡Šæœ€å¯†é›†çš„ x å€åŸŸ
      if (this.bricks.length === 0) return null;
      
      const buckets: number[] = new Array(10).fill(0);
      const bucketWidth = this.canvas.width / 10;
      
      for (const brick of this.bricks) {
        const bucketIndex = Math.floor((brick.x + brick.width / 2) / bucketWidth);
        if (bucketIndex >= 0 && bucketIndex < 10) {
          buckets[bucketIndex]++;
        }
      }
      
      let maxBucket = 0;
      let maxCount = 0;
      for (let i = 0; i < buckets.length; i++) {
        if (buckets[i] > maxCount) {
          maxCount = buckets[i];
          maxBucket = i;
        }
      }
      
      return (maxBucket + 0.5) * bucketWidth;
    }

    private updateAI() {
      if (!this.aiMode) return;
      if (this.gameState !== 'playing' && this.gameState !== 'ready') return;

      const paddleCenter = this.paddle.x + this.paddle.width / 2;
      let targetX: number;

      const predictedX = this.predictBallX();
      const urgency = this.ball.dy > 0 ? (this.paddle.y - this.ball.y) : 1000;
      
      if (urgency < 400 && this.ball.dy > 0) {
        // çƒå¿«è½ä¸‹ï¼Œè¨ˆç®—æœ€ä½³æ¥çƒä½ç½®
        targetX = this.findBestPaddlePosition(predictedX);
      } else {
        // çƒå¾€ä¸Šé£›ï¼Œå˜—è©¦åƒé“å…·æˆ–é å…ˆç§»å‹•
        const powerUp = this.findBestPowerUp();
        if (powerUp) {
          targetX = powerUp.x;
        } else {
          targetX = this.ball.x;
        }
      }

      // ç§»å‹•æ¿å­
      const diff = targetX - paddleCenter;
      const speed = this.AI_PADDLE_SPEED;
      
      if (Math.abs(diff) > speed) {
        this.paddle.x += diff > 0 ? speed : -speed;
      } else {
        this.paddle.x += diff;
      }
      
      this.paddle.x = Math.max(0, Math.min(this.paddle.x, this.canvas.width - this.paddle.width));
    }

    private findBestPaddlePosition(ballLandX: number): number {
      // æ¸¬è©¦ä¸åŒçš„æ¥çƒä½ç½®ï¼Œæ‰¾å‡ºèƒ½æ‰“åˆ°ç£šå¡Šçš„æœ€ä½³ä½ç½®
      const testPositions = [-0.4, -0.3, -0.2, -0.1, 0, 0.1, 0.2, 0.3, 0.4]; // ç›¸å°æ–¼æ¿å­å¯¬åº¦çš„åç§»
      let bestPosition = ballLandX;
      let bestScore = -Infinity;
      
      for (const offsetRatio of testPositions) {
        const paddleCenterX = ballLandX; // å‡è¨­æ¿å­ä¸­å¿ƒåœ¨é€™è£¡
        const hitPos = 0.5 + offsetRatio; // çƒæ‰“åœ¨æ¿å­çš„å“ªå€‹ä½ç½® (0-1)
        
        // è¨ˆç®—åå½ˆè§’åº¦ï¼ˆè¤‡è£½è‡ªçœŸå¯¦åå½ˆé‚è¼¯ï¼‰
        const angle = (hitPos - 0.5) * Math.PI * 0.6;
        const speed = this.ball.speed;
        const dx = speed * Math.sin(angle);
        const dy = -speed * Math.cos(angle);
        
        // æ¨¡æ“¬çƒé£›å‡ºå»çš„è»Œè·¡
        const score = this.simulateBallPath(ballLandX, this.paddle.y - this.ball.radius, dx, dy);
        
        if (score > bestScore) {
          bestScore = score;
          // æœ€ä½³æ¥çƒä½ç½® = çƒè½é» - åç§»é‡ï¼ˆè®“çƒæ‰“åœ¨æ¿å­çš„ç‰¹å®šä½ç½®ï¼‰
          bestPosition = ballLandX - offsetRatio * this.paddle.width;
        }
      }
      
      // ç¢ºä¿ä½ç½®åœ¨æœ‰æ•ˆç¯„åœå…§
      const halfPaddle = this.paddle.width / 2;
      bestPosition = Math.max(halfPaddle, Math.min(bestPosition, this.canvas.width - halfPaddle));
      
      return bestPosition;
    }

    private simulateBallPath(startX: number, startY: number, dx: number, dy: number): number {
      // æ¨¡æ“¬çƒçš„è»Œè·¡ï¼Œè¨ˆç®—èƒ½æ‰“åˆ°å¤šå°‘ç£šå¡Šçš„åˆ†æ•¸
      let x = startX;
      let y = startY;
      let score = 0;
      const hitBricks = new Set<number>();
      
      // æœ€å¤šæ¨¡æ“¬ 500 æ­¥
      for (let step = 0; step < 500; step++) {
        x += dx;
        y += dy;
        
        // ç‰†å£åå½ˆ
        if (x - this.ball.radius < 0) {
          x = this.ball.radius;
          dx = Math.abs(dx);
        }
        if (x + this.ball.radius > this.canvas.width) {
          x = this.canvas.width - this.ball.radius;
          dx = -Math.abs(dx);
        }
        if (y - this.ball.radius < 0) {
          y = this.ball.radius;
          dy = Math.abs(dy);
        }
        
        // æª¢æŸ¥æ˜¯å¦æ‰“åˆ°ç£šå¡Š
        for (let i = 0; i < this.bricks.length; i++) {
          if (hitBricks.has(i)) continue;
          const brick = this.bricks[i];
          
          if (x + this.ball.radius > brick.x &&
              x - this.ball.radius < brick.x + brick.width &&
              y + this.ball.radius > brick.y &&
              y - this.ball.radius < brick.y + brick.height) {
            hitBricks.add(i);
            score += brick.points;
            dy = -dy; // ç°¡åŒ–çš„åå½ˆ
          }
        }
        
        // çƒå›åˆ°æ¿å­é«˜åº¦å°±åœæ­¢æ¨¡æ“¬
        if (y > this.paddle.y) break;
      }
      
      return score;
    }

    private showOverlay(id: string) {
      document.getElementById(id)?.classList.remove('hidden');
    }

    private hideOverlay(id: string) {
      document.getElementById(id)?.classList.add('hidden');
    }

    private updateHUD() {
      document.getElementById('scoreDisplay')!.textContent = this.score.toString();
      document.getElementById('livesDisplay')!.textContent = 'â¤ï¸'.repeat(this.lives);
      document.getElementById('levelDisplay')!.textContent = this.level.toString();
    }

    private spawnParticles(x: number, y: number, color: string, count: number) {
      for (let i = 0; i < count; i++) {
        this.particles.push({
          x: x,
          y: y,
          vx: (Math.random() - 0.5) * 10,
          vy: (Math.random() - 0.5) * 10,
          life: 1,
          color: color,
          size: Math.random() * 5 + 2
        });
      }
    }

    private spawnPowerUp(x: number, y: number) {
      if (Math.random() < 0.15) {
        const types: PowerUp['type'][] = ['wide', 'multi', 'slow'];
        const type = types[Math.floor(Math.random() * types.length)];
        const colors = { wide: '#1dd1a1', multi: '#ff9ff3', slow: '#54a0ff' };
        this.powerUps.push({ x, y, type, color: colors[type] });
      }
    }

    private update() {
      if (this.gameState !== 'ready' && this.gameState !== 'playing') return;

      // AI æ§åˆ¶
      this.updateAI();

      // æŒçºŒæŒ‰éµç§»å‹•æ¿å­
      if (this.keys.left) {
        this.paddle.x -= this.PADDLE_SPEED;
      }
      if (this.keys.right) {
        this.paddle.x += this.PADDLE_SPEED;
      }
      this.paddle.x = Math.max(0, Math.min(this.paddle.x, this.canvas.width - this.paddle.width));

      // å¦‚æœçƒé‚„æ²’ç™¼å°„ï¼Œè·Ÿè‘—æ¿å­ç§»å‹•
      if (!this.ballLaunched) {
        this.ball.x = this.paddle.x + this.paddle.width / 2;
        this.ball.y = this.paddle.y - this.ball.radius - 2;
        return; // ä¸æ›´æ–°å…¶ä»–ç‰©ç†
      }

      // ç§»å‹•çƒ
      this.ball.x += this.ball.dx;
      this.ball.y += this.ball.dy;

      // ç‰†å£ç¢°æ’ï¼ˆä¿®æ­£ä½ç½®é¿å…å¡ä½ï¼‰
      if (this.ball.x - this.ball.radius < 0) {
        this.ball.x = this.ball.radius;
        this.ball.dx = Math.abs(this.ball.dx);
      }
      if (this.ball.x + this.ball.radius > this.canvas.width) {
        this.ball.x = this.canvas.width - this.ball.radius;
        this.ball.dx = -Math.abs(this.ball.dx);
      }
      if (this.ball.y - this.ball.radius < 0) {
        this.ball.y = this.ball.radius;
        this.ball.dy = Math.abs(this.ball.dy);
      }

      // æ‰è½
      if (this.ball.y + this.ball.radius > this.canvas.height) {
        this.lives--;
        this.updateHUD();
        if (this.lives <= 0) {
          this.gameOver();
        } else {
          this.resetBall();
          this.gameState = 'ready';
        }
      }

      // æ¿å­ç¢°æ’
      if (this.ball.y + this.ball.radius > this.paddle.y &&
          this.ball.y - this.ball.radius < this.paddle.y + this.paddle.height &&
          this.ball.x > this.paddle.x &&
          this.ball.x < this.paddle.x + this.paddle.width) {
        
        // æ¯æ¬¡ç¢°åˆ°æ¿å­åŠ é€Ÿ
        this.ball.speed = Math.min(this.ball.speed + this.SPEED_INCREMENT, this.MAX_SPEED);
        
        // æ ¹æ“šæ“Šä¸­ä½ç½®èª¿æ•´åå½ˆè§’åº¦
        const hitPos = (this.ball.x - this.paddle.x) / this.paddle.width;
        const angle = (hitPos - 0.5) * Math.PI * 0.6;
        const speed = this.ball.speed;
        
        this.ball.dx = speed * Math.sin(angle);
        this.ball.dy = -speed * Math.cos(angle);
        this.ball.y = this.paddle.y - this.ball.radius;
      }

      // ç£šå¡Šç¢°æ’
      for (let i = this.bricks.length - 1; i >= 0; i--) {
        const brick = this.bricks[i];
        
        if (this.ball.x + this.ball.radius > brick.x &&
            this.ball.x - this.ball.radius < brick.x + brick.width &&
            this.ball.y + this.ball.radius > brick.y &&
            this.ball.y - this.ball.radius < brick.y + brick.height) {
          
          this.ball.dy *= -1;
          brick.hits++;
          
          if (brick.hits >= brick.maxHits) {
            this.score += brick.points;
            this.spawnParticles(brick.x + brick.width/2, brick.y + brick.height/2, brick.color, 12);
            this.spawnPowerUp(brick.x + brick.width/2, brick.y + brick.height/2);
            this.bricks.splice(i, 1);
          }
          
          this.updateHUD();
          break;
        }
      }

      // é“å…·ç§»å‹•å’Œç¢°æ’
      for (let i = this.powerUps.length - 1; i >= 0; i--) {
        const pu = this.powerUps[i];
        pu.y += 2;
        
        // ç¢°åˆ°æ¿å­
        if (pu.y > this.paddle.y && pu.y < this.paddle.y + this.paddle.height &&
            pu.x > this.paddle.x && pu.x < this.paddle.x + this.paddle.width) {
          
          if (pu.type === 'wide') {
            this.paddle.width = Math.min(this.paddle.width + 30, 180);
          } else if (pu.type === 'slow') {
            this.ball.speed = Math.max(this.ball.speed - 1, 3);
          }
          
          this.spawnParticles(pu.x, pu.y, pu.color, 8);
          this.powerUps.splice(i, 1);
          continue;
        }
        
        // æ‰å‡ºç•«é¢
        if (pu.y > this.canvas.height) {
          this.powerUps.splice(i, 1);
        }
      }

      // æ›´æ–°ç²’å­
      this.particles = this.particles.filter(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.2;
        p.life -= 0.03;
        return p.life > 0;
      });

      // éé—œæª¢æ¸¬
      if (this.bricks.length === 0) {
        this.win();
      }
    }

    private win() {
      this.gameState = 'win';
      document.getElementById('winScore')!.textContent = this.score.toString();
      
      // AI æ¨¡å¼è‡ªå‹•é€²å…¥ä¸‹ä¸€é—œ
      if (this.aiMode) {
        this.level++;
        this.lives = Math.min(this.lives + 1, 5);
        setTimeout(() => {
          this.startGame(true);
        }, 1000);
      } else {
        this.showOverlay('winScreen');
      }
    }

    private gameOver() {
      this.gameState = 'gameover';
      document.getElementById('finalScore')!.textContent = this.score.toString();
      this.showOverlay('gameOverScreen');
    }

    private draw() {
      const ctx = this.ctx;
      const w = this.canvas.width;
      const h = this.canvas.height;

      // èƒŒæ™¯
      const gradient = ctx.createLinearGradient(0, 0, 0, h);
      gradient.addColorStop(0, '#0f0c29');
      gradient.addColorStop(0.5, '#302b63');
      gradient.addColorStop(1, '#24243e');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, w, h);

      // ç£šå¡Š
      for (const brick of this.bricks) {
        const alpha = brick.maxHits > 1 && brick.hits > 0 ? 0.5 : 1;
        ctx.fillStyle = brick.color;
        ctx.globalAlpha = alpha;
        ctx.shadowColor = brick.color;
        ctx.shadowBlur = 8;
        
        // åœ“è§’çŸ©å½¢
        const r = 4;
        ctx.beginPath();
        ctx.moveTo(brick.x + r, brick.y);
        ctx.lineTo(brick.x + brick.width - r, brick.y);
        ctx.quadraticCurveTo(brick.x + brick.width, brick.y, brick.x + brick.width, brick.y + r);
        ctx.lineTo(brick.x + brick.width, brick.y + brick.height - r);
        ctx.quadraticCurveTo(brick.x + brick.width, brick.y + brick.height, brick.x + brick.width - r, brick.y + brick.height);
        ctx.lineTo(brick.x + r, brick.y + brick.height);
        ctx.quadraticCurveTo(brick.x, brick.y + brick.height, brick.x, brick.y + brick.height - r);
        ctx.lineTo(brick.x, brick.y + r);
        ctx.quadraticCurveTo(brick.x, brick.y, brick.x + r, brick.y);
        ctx.fill();
        
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
      }

      // é“å…·
      for (const pu of this.powerUps) {
        ctx.fillStyle = pu.color;
        ctx.beginPath();
        ctx.arc(pu.x, pu.y, 10, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#fff';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const icons = { wide: 'â†”', multi: 'âš¡', slow: 'ğŸ¢' };
        ctx.fillText(icons[pu.type], pu.x, pu.y);
      }

      // ç²’å­
      for (const p of this.particles) {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      // æ¿å­
      const paddleGradient = ctx.createLinearGradient(this.paddle.x, 0, this.paddle.x + this.paddle.width, 0);
      paddleGradient.addColorStop(0, '#667eea');
      paddleGradient.addColorStop(1, '#764ba2');
      ctx.fillStyle = paddleGradient;
      ctx.shadowColor = '#667eea';
      ctx.shadowBlur = 15;
      
      ctx.beginPath();
      ctx.roundRect(this.paddle.x, this.paddle.y, this.paddle.width, this.paddle.height, 6);
      ctx.fill();
      ctx.shadowBlur = 0;

      // çƒ
      if (this.gameState === 'ready' || this.gameState === 'playing') {
        ctx.fillStyle = '#fff';
        ctx.shadowColor = '#fff';
        ctx.shadowBlur = 20;
        ctx.beginPath();
        ctx.arc(this.ball.x, this.ball.y, this.ball.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // ç™¼çƒæç¤º
        if (!this.ballLaunched) {
          ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
          ctx.font = '16px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('æŒ‰ç©ºç™½éµæˆ–é»æ“Šç™¼çƒ', w / 2, h / 2);
        }
      }
    }

    private gameLoop = () => {
      this.update();
      this.draw();
      requestAnimationFrame(this.gameLoop);
    }
  }

  // å•Ÿå‹•éŠæˆ²
  new BreakoutGame();
</script>
