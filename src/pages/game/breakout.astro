---
import BaseLayout from '@/layouts/BaseLayout.astro';
import Navbar from '@/components/Navbar.astro';
---
<BaseLayout title="æ‰“ç£šå¡Š">
  <Navbar currentPage="game" />
  <div class="container-fluid mt-3">
    <div class="row justify-content-center">
      <div class="col-auto">
        <div class="game-container">
          <canvas id="gameCanvas" width="480" height="600"></canvas>
          <div class="game-overlay" id="startScreen">
            <h2>ğŸ§± æ‰“ç£šå¡Š</h2>
            <p>æ‰“ç ´æ‰€æœ‰ç£šå¡Šï¼</p>
            <button class="btn btn-lg btn-primary" id="startBtn">é–‹å§‹éŠæˆ²</button>
            <div class="controls-info mt-3">
              <small>â† â†’ æˆ– æ»‘é¼ ç§»å‹•æ¿å­</small>
            </div>
          </div>
          <div class="game-overlay hidden" id="winScreen">
            <h2>ğŸ‰ æ­å–œéé—œï¼</h2>
            <p>åˆ†æ•¸: <span id="winScore">0</span></p>
            <button class="btn btn-lg btn-success" id="nextLevelBtn">ä¸‹ä¸€é—œ</button>
          </div>
          <div class="game-overlay hidden" id="gameOverScreen">
            <h2>ğŸ’€ éŠæˆ²çµæŸ</h2>
            <p>æœ€çµ‚åˆ†æ•¸: <span id="finalScore">0</span></p>
            <button class="btn btn-lg btn-primary" id="restartBtn">å†ç©ä¸€æ¬¡</button>
          </div>
          <div class="game-hud">
            <span class="hud-item">åˆ†æ•¸: <span id="scoreDisplay">0</span></span>
            <span class="hud-item">ç”Ÿå‘½: <span id="livesDisplay">â¤ï¸â¤ï¸â¤ï¸</span></span>
            <span class="hud-item">é—œå¡: <span id="levelDisplay">1</span></span>
          </div>
        </div>
        <div class="text-center mt-3">
          <a href="/game/" class="btn btn-outline-secondary">â† è¿”å›éŠæˆ²åˆ—è¡¨</a>
        </div>
      </div>
    </div>
  </div>
</BaseLayout>

<style>
  .game-container {
    position: relative;
    display: inline-block;
  }
  
  #gameCanvas {
    display: block;
    border-radius: 12px;
    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
  }
  
  .game-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.85);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    color: white;
    border-radius: 12px;
    text-align: center;
    padding: 20px;
  }
  
  .game-overlay.hidden {
    display: none;
  }
  
  .game-overlay h2 {
    font-size: 2.5rem;
    margin-bottom: 1rem;
  }
  
  .controls-info {
    color: #aaa;
  }
  
  .game-hud {
    display: flex;
    justify-content: space-between;
    padding: 10px 15px;
    background: linear-gradient(135deg, #1a1a2e, #16213e);
    border-radius: 0 0 12px 12px;
    color: white;
    font-size: 14px;
  }
  
  .hud-item {
    font-weight: bold;
  }
</style>

<script>
  interface Brick {
    x: number;
    y: number;
    width: number;
    height: number;
    color: string;
    hits: number;
    maxHits: number;
    points: number;
  }

  interface Particle {
    x: number;
    y: number;
    vx: number;
    vy: number;
    life: number;
    color: string;
    size: number;
  }

  interface PowerUp {
    x: number;
    y: number;
    type: 'wide' | 'multi' | 'slow';
    color: string;
  }

  class BreakoutGame {
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D;
    
    // éŠæˆ²ç‰©ä»¶
    private ball = { x: 240, y: 450, radius: 8, dx: 4, dy: -4, speed: 5 };
    private paddle = { x: 190, y: 560, width: 100, height: 12 };
    private bricks: Brick[] = [];
    private particles: Particle[] = [];
    private powerUps: PowerUp[] = [];
    
    // ç‹€æ…‹
    private score = 0;
    private lives = 3;
    private level = 1;
    private gameState: 'start' | 'playing' | 'win' | 'gameover' = 'start';

    // é¡è‰²æ–¹æ¡ˆ
    private readonly COLORS = [
      '#ff6b6b', '#feca57', '#48dbfb', '#1dd1a1', '#ff9ff3', '#54a0ff'
    ];

    constructor() {
      this.canvas = document.getElementById('gameCanvas') as HTMLCanvasElement;
      this.ctx = this.canvas.getContext('2d')!;
      
      this.bindEvents();
      this.gameLoop();
    }

    private createBricks() {
      this.bricks = [];
      const rows = 4 + Math.min(this.level, 4);
      const cols = 8;
      const brickWidth = 52;
      const brickHeight = 20;
      const padding = 6;
      const offsetX = 12;
      const offsetY = 50;

      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const maxHits = row < 2 && this.level > 1 ? 2 : 1;
          this.bricks.push({
            x: offsetX + col * (brickWidth + padding),
            y: offsetY + row * (brickHeight + padding),
            width: brickWidth,
            height: brickHeight,
            color: this.COLORS[row % this.COLORS.length],
            hits: 0,
            maxHits: maxHits,
            points: (rows - row) * 10 * maxHits
          });
        }
      }
    }

    private initGame() {
      this.ball = { 
        x: this.canvas.width / 2, 
        y: this.canvas.height - 100, 
        radius: 8, 
        dx: (Math.random() > 0.5 ? 1 : -1) * 4, 
        dy: -4, 
        speed: 5 + this.level * 0.5
      };
      this.paddle = { x: this.canvas.width / 2 - 50, y: 560, width: 100, height: 12 };
      this.particles = [];
      this.powerUps = [];
      this.createBricks();
    }

    private resetBall() {
      this.ball.x = this.canvas.width / 2;
      this.ball.y = this.canvas.height - 100;
      this.ball.dx = (Math.random() > 0.5 ? 1 : -1) * 4;
      this.ball.dy = -4;
    }

    private bindEvents() {
      document.getElementById('startBtn')?.addEventListener('click', () => this.startGame());
      document.getElementById('restartBtn')?.addEventListener('click', () => {
        this.level = 1;
        this.score = 0;
        this.lives = 3;
        this.startGame();
      });
      document.getElementById('nextLevelBtn')?.addEventListener('click', () => {
        this.level++;
        this.lives = Math.min(this.lives + 1, 5);
        this.startGame();
      });

      // éµç›¤æ§åˆ¶
      document.addEventListener('keydown', (e) => {
        if (this.gameState !== 'playing') return;
        if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
          this.paddle.x -= 30;
        }
        if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
          this.paddle.x += 30;
        }
        this.paddle.x = Math.max(0, Math.min(this.paddle.x, this.canvas.width - this.paddle.width));
      });

      // æ»‘é¼ æ§åˆ¶
      this.canvas.addEventListener('mousemove', (e) => {
        if (this.gameState !== 'playing') return;
        const rect = this.canvas.getBoundingClientRect();
        const scaleX = this.canvas.width / rect.width;
        this.paddle.x = (e.clientX - rect.left) * scaleX - this.paddle.width / 2;
        this.paddle.x = Math.max(0, Math.min(this.paddle.x, this.canvas.width - this.paddle.width));
      });

      // è§¸æ§æ§åˆ¶
      this.canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (this.gameState !== 'playing') return;
        const rect = this.canvas.getBoundingClientRect();
        const scaleX = this.canvas.width / rect.width;
        this.paddle.x = (e.touches[0].clientX - rect.left) * scaleX - this.paddle.width / 2;
        this.paddle.x = Math.max(0, Math.min(this.paddle.x, this.canvas.width - this.paddle.width));
      });
    }

    private startGame() {
      this.initGame();
      this.gameState = 'playing';
      this.hideOverlay('startScreen');
      this.hideOverlay('gameOverScreen');
      this.hideOverlay('winScreen');
      this.updateHUD();
    }

    private showOverlay(id: string) {
      document.getElementById(id)?.classList.remove('hidden');
    }

    private hideOverlay(id: string) {
      document.getElementById(id)?.classList.add('hidden');
    }

    private updateHUD() {
      document.getElementById('scoreDisplay')!.textContent = this.score.toString();
      document.getElementById('livesDisplay')!.textContent = 'â¤ï¸'.repeat(this.lives);
      document.getElementById('levelDisplay')!.textContent = this.level.toString();
    }

    private spawnParticles(x: number, y: number, color: string, count: number) {
      for (let i = 0; i < count; i++) {
        this.particles.push({
          x: x,
          y: y,
          vx: (Math.random() - 0.5) * 10,
          vy: (Math.random() - 0.5) * 10,
          life: 1,
          color: color,
          size: Math.random() * 5 + 2
        });
      }
    }

    private spawnPowerUp(x: number, y: number) {
      if (Math.random() < 0.15) {
        const types: PowerUp['type'][] = ['wide', 'multi', 'slow'];
        const type = types[Math.floor(Math.random() * types.length)];
        const colors = { wide: '#1dd1a1', multi: '#ff9ff3', slow: '#54a0ff' };
        this.powerUps.push({ x, y, type, color: colors[type] });
      }
    }

    private update() {
      if (this.gameState !== 'playing') return;

      // ç§»å‹•çƒ
      this.ball.x += this.ball.dx;
      this.ball.y += this.ball.dy;

      // ç‰†å£ç¢°æ’
      if (this.ball.x - this.ball.radius < 0 || this.ball.x + this.ball.radius > this.canvas.width) {
        this.ball.dx *= -1;
      }
      if (this.ball.y - this.ball.radius < 0) {
        this.ball.dy *= -1;
      }

      // æ‰è½
      if (this.ball.y + this.ball.radius > this.canvas.height) {
        this.lives--;
        this.updateHUD();
        if (this.lives <= 0) {
          this.gameOver();
        } else {
          this.resetBall();
        }
      }

      // æ¿å­ç¢°æ’
      if (this.ball.y + this.ball.radius > this.paddle.y &&
          this.ball.y - this.ball.radius < this.paddle.y + this.paddle.height &&
          this.ball.x > this.paddle.x &&
          this.ball.x < this.paddle.x + this.paddle.width) {
        
        // æ ¹æ“šæ“Šä¸­ä½ç½®èª¿æ•´åå½ˆè§’åº¦
        const hitPos = (this.ball.x - this.paddle.x) / this.paddle.width;
        const angle = (hitPos - 0.5) * Math.PI * 0.6;
        const speed = this.ball.speed;
        
        this.ball.dx = speed * Math.sin(angle);
        this.ball.dy = -speed * Math.cos(angle);
        this.ball.y = this.paddle.y - this.ball.radius;
      }

      // ç£šå¡Šç¢°æ’
      for (let i = this.bricks.length - 1; i >= 0; i--) {
        const brick = this.bricks[i];
        
        if (this.ball.x + this.ball.radius > brick.x &&
            this.ball.x - this.ball.radius < brick.x + brick.width &&
            this.ball.y + this.ball.radius > brick.y &&
            this.ball.y - this.ball.radius < brick.y + brick.height) {
          
          this.ball.dy *= -1;
          brick.hits++;
          
          if (brick.hits >= brick.maxHits) {
            this.score += brick.points;
            this.spawnParticles(brick.x + brick.width/2, brick.y + brick.height/2, brick.color, 12);
            this.spawnPowerUp(brick.x + brick.width/2, brick.y + brick.height/2);
            this.bricks.splice(i, 1);
          }
          
          this.updateHUD();
          break;
        }
      }

      // é“å…·ç§»å‹•å’Œç¢°æ’
      for (let i = this.powerUps.length - 1; i >= 0; i--) {
        const pu = this.powerUps[i];
        pu.y += 2;
        
        // ç¢°åˆ°æ¿å­
        if (pu.y > this.paddle.y && pu.y < this.paddle.y + this.paddle.height &&
            pu.x > this.paddle.x && pu.x < this.paddle.x + this.paddle.width) {
          
          if (pu.type === 'wide') {
            this.paddle.width = Math.min(this.paddle.width + 30, 180);
          } else if (pu.type === 'slow') {
            this.ball.speed = Math.max(this.ball.speed - 1, 3);
          }
          
          this.spawnParticles(pu.x, pu.y, pu.color, 8);
          this.powerUps.splice(i, 1);
          continue;
        }
        
        // æ‰å‡ºç•«é¢
        if (pu.y > this.canvas.height) {
          this.powerUps.splice(i, 1);
        }
      }

      // æ›´æ–°ç²’å­
      this.particles = this.particles.filter(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.2;
        p.life -= 0.03;
        return p.life > 0;
      });

      // éé—œæª¢æ¸¬
      if (this.bricks.length === 0) {
        this.win();
      }
    }

    private win() {
      this.gameState = 'win';
      document.getElementById('winScore')!.textContent = this.score.toString();
      this.showOverlay('winScreen');
    }

    private gameOver() {
      this.gameState = 'gameover';
      document.getElementById('finalScore')!.textContent = this.score.toString();
      this.showOverlay('gameOverScreen');
    }

    private draw() {
      const ctx = this.ctx;
      const w = this.canvas.width;
      const h = this.canvas.height;

      // èƒŒæ™¯
      const gradient = ctx.createLinearGradient(0, 0, 0, h);
      gradient.addColorStop(0, '#0f0c29');
      gradient.addColorStop(0.5, '#302b63');
      gradient.addColorStop(1, '#24243e');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, w, h);

      // ç£šå¡Š
      for (const brick of this.bricks) {
        const alpha = brick.maxHits > 1 && brick.hits > 0 ? 0.5 : 1;
        ctx.fillStyle = brick.color;
        ctx.globalAlpha = alpha;
        ctx.shadowColor = brick.color;
        ctx.shadowBlur = 8;
        
        // åœ“è§’çŸ©å½¢
        const r = 4;
        ctx.beginPath();
        ctx.moveTo(brick.x + r, brick.y);
        ctx.lineTo(brick.x + brick.width - r, brick.y);
        ctx.quadraticCurveTo(brick.x + brick.width, brick.y, brick.x + brick.width, brick.y + r);
        ctx.lineTo(brick.x + brick.width, brick.y + brick.height - r);
        ctx.quadraticCurveTo(brick.x + brick.width, brick.y + brick.height, brick.x + brick.width - r, brick.y + brick.height);
        ctx.lineTo(brick.x + r, brick.y + brick.height);
        ctx.quadraticCurveTo(brick.x, brick.y + brick.height, brick.x, brick.y + brick.height - r);
        ctx.lineTo(brick.x, brick.y + r);
        ctx.quadraticCurveTo(brick.x, brick.y, brick.x + r, brick.y);
        ctx.fill();
        
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
      }

      // é“å…·
      for (const pu of this.powerUps) {
        ctx.fillStyle = pu.color;
        ctx.beginPath();
        ctx.arc(pu.x, pu.y, 10, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#fff';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const icons = { wide: 'â†”', multi: 'âš¡', slow: 'ğŸ¢' };
        ctx.fillText(icons[pu.type], pu.x, pu.y);
      }

      // ç²’å­
      for (const p of this.particles) {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      // æ¿å­
      const paddleGradient = ctx.createLinearGradient(this.paddle.x, 0, this.paddle.x + this.paddle.width, 0);
      paddleGradient.addColorStop(0, '#667eea');
      paddleGradient.addColorStop(1, '#764ba2');
      ctx.fillStyle = paddleGradient;
      ctx.shadowColor = '#667eea';
      ctx.shadowBlur = 15;
      
      ctx.beginPath();
      ctx.roundRect(this.paddle.x, this.paddle.y, this.paddle.width, this.paddle.height, 6);
      ctx.fill();
      ctx.shadowBlur = 0;

      // çƒ
      if (this.gameState === 'playing') {
        ctx.fillStyle = '#fff';
        ctx.shadowColor = '#fff';
        ctx.shadowBlur = 20;
        ctx.beginPath();
        ctx.arc(this.ball.x, this.ball.y, this.ball.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }
    }

    private gameLoop = () => {
      this.update();
      this.draw();
      requestAnimationFrame(this.gameLoop);
    }
  }

  // å•Ÿå‹•éŠæˆ²
  new BreakoutGame();
</script>
