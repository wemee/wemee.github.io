---
import BaseLayout from '@/layouts/BaseLayout.astro';
import Navbar from '@/components/Navbar.astro';
---
<BaseLayout 
  title="ä¸‹æ¨“æ¢¯éŠæˆ² | æŒ«å±å‹‡çš„éŠæˆ²é–“" 
  description="ç¶“å…¸åæ‡‰éŠæˆ²ã€Œä¸‹æ¨“æ¢¯ã€ï¼ŒæŒ‘æˆ°ä½ çš„åæ‡‰æ¥µé™ï¼æ˜¯ç”·äººå°±ä¸‹ 100 å±¤ã€‚æ”¯æ´è§¸æ§ã€éµç›¤èˆ‡ AI è‡ªå‹•éŠç©æ¨¡å¼ã€‚"
>
  <Navbar currentPage="game" />
  <div class="container-fluid mt-3">
    <div class="row justify-content-center">
      <div class="col-auto">
        <div class="game-container">
          <canvas id="gameCanvas" width="400" height="600"></canvas>
          <div class="game-overlay" id="startScreen">
            <h2>ğŸƒ ä¸‹æ¨“æ¢¯</h2>
            <p>ä¸è¦æ‰å‡ºå»ï¼Œä¹Ÿåˆ¥è¢«é ‚åˆ°é ‚éƒ¨ï¼</p>
            <button class="btn btn-lg btn-success" id="startBtn">é–‹å§‹éŠæˆ²</button>
            <button class="btn btn-lg btn-warning mt-2" id="aiStartBtn">ğŸ¤– AI æ¨¡å¼</button>
            <div class="controls-info mt-3">
              <small>â† â†’ æˆ– A D ç§»å‹• | ç©ºç™½éµæš«åœ</small>
            </div>
          </div>
          <div class="game-overlay hidden" id="gameOverScreen">
            <h2>ğŸ’€ éŠæˆ²çµæŸ</h2>
            <p>åˆ†æ•¸: <span id="finalScore">0</span></p>
            <p>æœ€é«˜åˆ†: <span id="highScore">0</span></p>
            <button class="btn btn-lg btn-primary" id="restartBtn">å†ç©ä¸€æ¬¡</button>
          </div>
          <div class="game-overlay hidden" id="pauseScreen">
            <h2>â¸ï¸ æš«åœ</h2>
            <p>æŒ‰ç©ºç™½éµç¹¼çºŒ</p>
          </div>
          <div class="score-display">
            <span id="aiIndicator" class="hidden">ğŸ¤– </span>
            <span id="scoreDisplay">0</span>
          </div>
        </div>
      </div>
    </div>
  </div>
</BaseLayout>

<style>
  .game-container {
    position: relative;
    display: inline-block;
  }
  
  #gameCanvas {
    display: block;
    border-radius: 12px;
    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
  }
  
  .game-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.8);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    color: white;
    border-radius: 12px;
    text-align: center;
    padding: 20px;
  }
  
  .game-overlay.hidden {
    display: none;
  }
  
  .game-overlay h2 {
    font-size: 2.5rem;
    margin-bottom: 1rem;
  }
  
  .controls-info {
    color: #aaa;
  }
  
  .score-display {
    position: absolute;
    top: 15px;
    left: 15px;
    font-size: 28px;
    font-weight: bold;
    color: white;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    pointer-events: none;
  }
</style>

<script>
  // === å‹åˆ¥å®šç¾© ===
  interface Stair {
    x: number;
    y: number;
    width: number;
    type: 'normal' | 'bounce' | 'fragile' | 'moving';
    broken: boolean;
    moveDir?: number;
    color: string;
  }

  interface Particle {
    x: number;
    y: number;
    vx: number;
    vy: number;
    life: number;
    color: string;
    size: number;
  }

  interface Star {
    x: number;
    y: number;
    size: number;
    speed: number;
    opacity: number;
  }

  // === éŠæˆ²é¡åˆ¥ ===
  class StairsGame {
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D;
    
    // ç©å®¶
    private player = { x: 200, y: 100, radius: 15, vy: 0, vx: 0, onStair: false, expression: 'ğŸ˜Š' };
    
    // éŠæˆ²ç‹€æ…‹
    private stairs: Stair[] = [];
    private particles: Particle[] = [];
    private stars: Star[] = [];
    private score = 0;
    private highScore = 0;
    private gameState: 'start' | 'playing' | 'paused' | 'gameover' = 'start';
    private scrollSpeed = 2;
    private keys = { left: false, right: false };
    
    // AI æ¨¡å¼
    private aiMode = false;
    private readonly AI_SPEED = 8;
    private lastAIAction: 'left' | 'right' | 'stop' = 'stop';
    
    // å¸¸æ•¸
    private readonly GRAVITY = 0.3;
    private readonly MOVE_SPEED = 5;
    private readonly STAIR_HEIGHT = 12;
    private readonly STAIR_GAP = 70;

    constructor() {
      this.canvas = document.getElementById('gameCanvas') as HTMLCanvasElement;
      this.ctx = this.canvas.getContext('2d')!;
      
      this.highScore = parseInt(localStorage.getItem('stairsHighScore') || '0');
      
      this.initStars();
      this.bindEvents();
      this.gameLoop();
    }

    private initStars() {
      for (let i = 0; i < 50; i++) {
        this.stars.push({
          x: Math.random() * this.canvas.width,
          y: Math.random() * this.canvas.height,
          size: Math.random() * 2 + 0.5,
          speed: Math.random() * 0.5 + 0.2,
          opacity: Math.random() * 0.5 + 0.3
        });
      }
    }

    private createStair(y: number): Stair {
      const types: Stair['type'][] = ['normal', 'normal', 'normal', 'normal', 'bounce', 'fragile', 'moving'];
      const type = this.score > 10 ? types[Math.floor(Math.random() * types.length)] : 'normal';
      
      const colors: Record<Stair['type'], string> = {
        normal: '#78c2ad',
        bounce: '#5cb85c',
        fragile: '#d9534f',
        moving: '#9b59b6'
      };

      return {
        x: Math.random() * (this.canvas.width - 80) + 20,
        y: y,
        width: Math.random() * 60 + 60,
        type: type,
        broken: false,
        moveDir: type === 'moving' ? (Math.random() > 0.5 ? 1 : -1) : undefined,
        color: colors[type]
      };
    }

    private initGame() {
      this.player = { x: 200, y: 100, radius: 15, vy: 0, vx: 0, onStair: false, expression: 'ğŸ˜Š' };
      this.score = 0;
      this.scrollSpeed = 2;
      this.stairs = [];
      this.particles = [];
      
      // å»ºç«‹åˆå§‹æ¨“æ¢¯
      for (let i = 0; i < 10; i++) {
        this.stairs.push(this.createStair(150 + i * this.STAIR_GAP));
      }
    }

    private bindEvents() {
      document.getElementById('startBtn')?.addEventListener('click', () => this.startGame(false));
      document.getElementById('aiStartBtn')?.addEventListener('click', () => this.startGame(true));
      document.getElementById('restartBtn')?.addEventListener('click', () => this.startGame(this.aiMode));

      document.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') this.keys.left = true;
        if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') this.keys.right = true;
        if (e.key === ' ') {
          e.preventDefault();
          if (this.gameState === 'playing') {
            this.gameState = 'paused';
            this.showOverlay('pauseScreen');
          } else if (this.gameState === 'paused') {
            this.gameState = 'playing';
            this.hideOverlay('pauseScreen');
          }
        }
      });

      document.addEventListener('keyup', (e) => {
        if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') this.keys.left = false;
        if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') this.keys.right = false;
      });

      // è§¸æ§æ”¯æ´
      let touchStartX = 0;
      this.canvas.addEventListener('touchstart', (e) => {
        touchStartX = e.touches[0].clientX;
      });
      this.canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        const touchX = e.touches[0].clientX;
        const diff = touchX - touchStartX;
        this.keys.left = diff < -10;
        this.keys.right = diff > 10;
      });
      this.canvas.addEventListener('touchend', () => {
        this.keys.left = false;
        this.keys.right = false;
      });
    }

    private startGame(enableAI: boolean = false) {
      this.aiMode = enableAI;
      this.initGame();
      this.gameState = 'playing';
      this.hideOverlay('startScreen');
      this.hideOverlay('gameOverScreen');
      
      // é¡¯ç¤º/éš±è— AI æŒ‡ç¤ºå™¨
      const aiIndicator = document.getElementById('aiIndicator');
      if (aiIndicator) {
        aiIndicator.classList.toggle('hidden', !this.aiMode);
      }
    }

    private showOverlay(id: string) {
      document.getElementById(id)?.classList.remove('hidden');
    }

    private hideOverlay(id: string) {
      document.getElementById(id)?.classList.add('hidden');
    }

    private spawnParticles(x: number, y: number, color: string, count: number) {
      for (let i = 0; i < count; i++) {
        this.particles.push({
          x: x,
          y: y,
          vx: (Math.random() - 0.5) * 8,
          vy: (Math.random() - 0.5) * 8,
          life: 1,
          color: color,
          size: Math.random() * 4 + 2
        });
      }
    }

    // === AI é‚è¼¯ (The Strongest AI) ===
    private lockedAction: 'left' | 'right' | null = null;
    private lockedStair: Stair | null = null;
    
    private updateAI() {
      const currentStair = this.findCurrentStair();
      
      // æª¢æŸ¥æ˜¯å¦éœ€è¦è§£é™¤é–å®š
      if (this.lockedAction) {
        // å¦‚æœç©å®¶å·²ç¶“ä¸åœ¨é–å®šæ™‚çš„æ¨“æ¢¯ä¸Šï¼ˆæˆåŠŸè·³ä¸‹å»äº†ï¼‰ï¼Œè§£é™¤é–å®š
        if (!this.player.onStair || currentStair !== this.lockedStair) {
          this.lockedAction = null;
          this.lockedStair = null;
        } else {
          // ç¹¼çºŒåŸ·è¡Œé–å®šçš„å‹•ä½œ
          this.keys.left = this.lockedAction === 'left';
          this.keys.right = this.lockedAction === 'right';
          return;
        }
      }
      
      const bestMove = this.findBestMove();
      
      if (bestMove) {
        this.keys.left = bestMove.action === 'left';
        this.keys.right = bestMove.action === 'right';
        this.lastAIAction = bestMove.action;
        
        // å¦‚æœé¸æ“‡äº†ç§»å‹•ï¼ˆéstopï¼‰ï¼Œä¸”ç«™åœ¨æ¨“æ¢¯ä¸Šï¼Œé–å®šé€™å€‹å‹•ä½œ
        if (bestMove.action !== 'stop' && currentStair && bestMove.score > -5000) {
          this.lockedAction = bestMove.action;
          this.lockedStair = currentStair;
        }
      } else {
        // ç„¡è·¯å¯èµ°ï¼Œå¾€ä¸­é–“
        const centerDiff = this.canvas.width / 2 - this.player.x;
        this.keys.left = centerDiff < -10;
        this.keys.right = centerDiff > 10;
      }
    }

    private findBestMove(): { action: 'left' | 'right' | 'stop', score: number } | null {
      const candidates: { action: 'left' | 'right' | 'stop', score: number }[] = [];
      const currentStair = this.findCurrentStair();
      const actions: ('left' | 'right' | 'stop')[] = ['left', 'right', 'stop'];
      
      // æ¨¡æ“¬ 90 å¹€ (ç´„ 1.5 ç§’ @ 60fps)
      const SIM_FRAMES = 90;
      
      for (const action of actions) {
        let score = 0;
        
        // è¤‡è£½ç©å®¶ç‹€æ…‹
        let sim = {
          x: this.player.x,
          y: this.player.y,
          vx: this.player.vx,
          vy: this.player.vy,
          onStair: this.player.onStair,
          radius: this.player.radius
        };
        
        let lowestY = sim.y;
        let landedStair: Stair | null = null;
        let survived = false;
        
        for (let frame = 0; frame < SIM_FRAMES; frame++) {
          // 1. ç©å®¶æ°´å¹³ç§»å‹•
          if (action === 'left') sim.vx = -this.MOVE_SPEED;
          else if (action === 'right') sim.vx = this.MOVE_SPEED;
          else sim.vx *= 0.8;
          
          sim.x += sim.vx;
          sim.x = Math.max(sim.radius, Math.min(sim.x, this.canvas.width - sim.radius));
          
          // 2. é‡åŠ›
          if (!sim.onStair) {
            sim.vy += this.GRAVITY;
          }
          sim.y += sim.vy;
          
          // 3. å ´æ™¯æ»¾å‹• (ç©å®¶ç›¸å°ä¸Šç§»)
          sim.y -= this.scrollSpeed;
          
          // 4. æ›´æ–°æœ€ä½é»
          if (sim.y > lowestY) lowestY = sim.y;
          
          // 5. ç¢°æ’æª¢æ¸¬
          sim.onStair = false;
          for (const stair of this.stairs) {
            if (stair.broken) continue;
            
            // é æ¸¬æ¨“æ¢¯åœ¨ frame å¹€å¾Œçš„ä½ç½®
            let stairX = stair.x;
            let stairY = stair.y - this.scrollSpeed * frame;
            
            // ç§»å‹•æ¨“æ¢¯
            if (stair.type === 'moving' && stair.moveDir) {
              stairX += stair.moveDir * 2 * frame;
              // é‚Šç•Œåå½ˆ (ç°¡åŒ–)
              if (stairX < 10) stairX = 10;
              if (stairX + stair.width > this.canvas.width - 10) stairX = this.canvas.width - 10 - stair.width;
            }
            
            const pBottom = sim.y + sim.radius;
            if (sim.x > stairX - sim.radius &&
                sim.x < stairX + stair.width + sim.radius &&
                pBottom >= stairY &&
                pBottom <= stairY + this.STAIR_HEIGHT + Math.max(sim.vy, 1)) {
              
              if (sim.vy >= 0) {
                sim.y = stairY - sim.radius;
                sim.vy = 0;
                sim.onStair = true;
                landedStair = stair;
                if (stair.type !== 'fragile') survived = true;
                
                // æ¨¡æ“¬è·Ÿéš¨ç§»å‹•æ¨“æ¢¯
                if (stair.type === 'moving' && stair.moveDir) {
                  sim.x += stair.moveDir * 2;
                }
              }
            }
          }
          
          // 6. æ­»äº¡æª¢æ¸¬
          if (sim.y < -20) { // è§¸é ‚ = ç«‹å³æ­» = æœ€å·®
            score = -20000;
            break;
          }
          if (sim.y > this.canvas.height + 50) { // æ‰åº• = å»¶é²æ­» = é‚„æœ‰æ©Ÿæœƒï¼ˆæ–°æ¨“æ¢¯å¯èƒ½å‡ºç¾ï¼‰
            score = -5000 + (frame * 10); // å­˜æ´»è¶Šä¹…è¶Šå¥½
            break;
          }
          
          // å¦‚æœå®‰å…¨è‘—é™¸åˆ°æ–°æ¨“æ¢¯ï¼Œææ—©çµæŸ
          if (sim.onStair && landedStair && landedStair !== currentStair && survived) {
            break;
          }
        }
        
        // è©•åˆ†
        if (score > -5000) {
          // é«˜åº¦åˆ† (è¶Šä½è¶Šå¥½)
          score += (lowestY / this.canvas.height) * 500;
          
          // æ¨“æ¢¯é¡å‹åˆ†
          if (landedStair) {
            if (landedStair.type === 'normal') score += 300;
            else if (landedStair.type === 'moving') score += 200;
            else if (landedStair.type === 'bounce') score += 50;
            else if (landedStair.type === 'fragile') score -= 300;
          }
          
          // æˆåŠŸè½‰ç§»åˆ†
          if (landedStair && landedStair !== currentStair) {
            score += 500;
          }
          
          // å®‰å…¨åœç•™åˆ† (åªæœ‰åœ¨å®‰å…¨é«˜åº¦æ‰çå‹µ)
          if (action === 'stop' && currentStair && currentStair.type !== 'fragile' && this.player.y > 300) {
            score += 100;
          }
          
          // æ…£æ€§åŠ åˆ†ï¼šç¶­æŒä¸Šä¸€å€‹å‹•ä½œï¼Œé˜²æ­¢æŠ–å‹•
          if (action === this.lastAIAction && action !== 'stop') {
            score += 150;
          }
        }
        
        candidates.push({ action, score });
      }
      
      candidates.sort((a, b) => b.score - a.score);
      return candidates.length > 0 ? candidates[0] : null;
    }

    private findCurrentStair(): Stair | null {
      for (const stair of this.stairs) {
        if (stair.broken) continue;
        const pBottom = this.player.y + this.player.radius;
        if (this.player.x > stair.x - this.player.radius &&
            this.player.x < stair.x + stair.width + this.player.radius &&
            Math.abs(pBottom - stair.y) < 10) {
          return stair;
        }
      }
      return null;
    }

    private update() {
      if (this.gameState !== 'playing') return;

      // AI æ§åˆ¶
      if (this.aiMode) {
        this.updateAI();
      }

      // æ›´æ–°ç©å®¶
      if (this.keys.left) this.player.vx = -this.MOVE_SPEED;
      else if (this.keys.right) this.player.vx = this.MOVE_SPEED;
      else this.player.vx *= 0.8;

      this.player.x += this.player.vx;
      this.player.x = Math.max(this.player.radius, Math.min(this.player.x, this.canvas.width - this.player.radius));

      // é‡åŠ›
      if (!this.player.onStair) {
        this.player.vy += this.GRAVITY;
      }
      this.player.y += this.player.vy;

      // ç¢°æ’æª¢æ¸¬
      this.player.onStair = false;
      for (const stair of this.stairs) {
        if (stair.broken) continue;
        
        const playerBottom = this.player.y + this.player.radius;
        const playerTop = this.player.y - this.player.radius;
        
        if (this.player.x > stair.x - this.player.radius && 
            this.player.x < stair.x + stair.width + this.player.radius &&
            playerBottom >= stair.y && 
            playerBottom <= stair.y + this.STAIR_HEIGHT + this.player.vy) {
          
          if (this.player.vy >= 0) {
            this.player.y = stair.y - this.player.radius;
            this.player.onStair = true;

            if (stair.type === 'bounce') {
              this.player.vy = -12;
              this.player.onStair = false;
              this.spawnParticles(this.player.x, this.player.y + this.player.radius, '#5cb85c', 8);
              this.player.expression = 'ğŸ˜®';
            } else if (stair.type === 'fragile') {
              stair.broken = true;
              this.spawnParticles(stair.x + stair.width/2, stair.y, '#d9534f', 15);
              this.player.expression = 'ğŸ˜±';
            } else {
              this.player.vy = 0;
              this.player.expression = 'ğŸ˜Š';
            }

            // è·Ÿéš¨ç§»å‹•æ¨“æ¢¯
            if (stair.type === 'moving' && stair.moveDir) {
              this.player.x += stair.moveDir * 2;
            }
          }
        }
      }

      // æ¨“æ¢¯ç§»å‹•ï¼ˆå‘ä¸Šæ»¾å‹•ï¼‰
      for (const stair of this.stairs) {
        stair.y -= this.scrollSpeed;
        
        // ç§»å‹•æ¨“æ¢¯å·¦å³ç§»å‹•
        if (stair.type === 'moving' && stair.moveDir) {
          stair.x += stair.moveDir * 2;
          if (stair.x <= 10 || stair.x + stair.width >= this.canvas.width - 10) {
            stair.moveDir *= -1;
          }
        }

        // å›æ”¶ä¸¦é‡ç”Ÿæ¨“æ¢¯
        if (stair.y + this.STAIR_HEIGHT < 0) {
          Object.assign(stair, this.createStair(this.canvas.height + 50));
          stair.broken = false;
          this.score++;
        }
      }

      // é›£åº¦éå¢
      this.scrollSpeed = 2 + Math.floor(this.score / 10) * 0.5;
      if (this.scrollSpeed > 6) this.scrollSpeed = 6;

      // ç©å®¶è·Ÿéš¨æ»¾å‹•
      this.player.y -= this.scrollSpeed;

      // æ›´æ–°ç²’å­
      this.particles = this.particles.filter(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.2;
        p.life -= 0.02;
        return p.life > 0;
      });

      // æ›´æ–°æ˜Ÿæ˜Ÿ
      for (const star of this.stars) {
        star.y -= star.speed;
        if (star.y < 0) {
          star.y = this.canvas.height;
          star.x = Math.random() * this.canvas.width;
        }
      }

      // æ­»äº¡æª¢æ¸¬
      if (this.player.y > this.canvas.height + 50 || this.player.y < -20) {
        this.gameOver();
      }

      // æ›´æ–°åˆ†æ•¸é¡¯ç¤º
      document.getElementById('scoreDisplay')!.textContent = this.score.toString();
    }

    private gameOver() {
      this.gameState = 'gameover';
      this.spawnParticles(this.player.x, this.player.y, '#fff', 30);
      
      if (this.score > this.highScore) {
        this.highScore = this.score;
        localStorage.setItem('stairsHighScore', this.highScore.toString());
      }

      document.getElementById('finalScore')!.textContent = this.score.toString();
      document.getElementById('highScore')!.textContent = this.highScore.toString();
      this.showOverlay('gameOverScreen');
    }

    private draw() {
      const ctx = this.ctx;
      const w = this.canvas.width;
      const h = this.canvas.height;

      // èƒŒæ™¯æ¼¸å±¤
      const gradient = ctx.createLinearGradient(0, 0, 0, h);
      gradient.addColorStop(0, '#1a1a2e');
      gradient.addColorStop(1, '#16213e');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, w, h);

      // æ˜Ÿæ˜Ÿ
      for (const star of this.stars) {
        ctx.fillStyle = `rgba(255, 255, 255, ${star.opacity})`;
        ctx.beginPath();
        ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
        ctx.fill();
      }

      // æ¨“æ¢¯
      for (const stair of this.stairs) {
        if (stair.broken) continue;
        
        ctx.fillStyle = stair.color;
        ctx.shadowColor = stair.color;
        ctx.shadowBlur = 10;
        
        // åœ“è§’çŸ©å½¢
        const r = 6;
        ctx.beginPath();
        ctx.moveTo(stair.x + r, stair.y);
        ctx.lineTo(stair.x + stair.width - r, stair.y);
        ctx.quadraticCurveTo(stair.x + stair.width, stair.y, stair.x + stair.width, stair.y + r);
        ctx.lineTo(stair.x + stair.width, stair.y + this.STAIR_HEIGHT - r);
        ctx.quadraticCurveTo(stair.x + stair.width, stair.y + this.STAIR_HEIGHT, stair.x + stair.width - r, stair.y + this.STAIR_HEIGHT);
        ctx.lineTo(stair.x + r, stair.y + this.STAIR_HEIGHT);
        ctx.quadraticCurveTo(stair.x, stair.y + this.STAIR_HEIGHT, stair.x, stair.y + this.STAIR_HEIGHT - r);
        ctx.lineTo(stair.x, stair.y + r);
        ctx.quadraticCurveTo(stair.x, stair.y, stair.x + r, stair.y);
        ctx.fill();
        
        ctx.shadowBlur = 0;
      }

      // ç²’å­
      for (const p of this.particles) {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      // ç©å®¶
      if (this.gameState === 'playing' || this.gameState === 'paused') {
        // èº«é«”
        ctx.fillStyle = '#ffcc5c';
        ctx.shadowColor = '#ffcc5c';
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.arc(this.player.x, this.player.y, this.player.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // è¡¨æƒ…
        ctx.font = '18px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.player.expression, this.player.x, this.player.y);
      }

      // å±éšªå€åŸŸæç¤º
      if (this.gameState === 'playing') {
        // é ‚éƒ¨å±éšª
        ctx.fillStyle = 'rgba(255, 0, 0, 0.1)';
        ctx.fillRect(0, 0, w, 30);
        
        // åº•éƒ¨å±éšª
        ctx.fillStyle = 'rgba(255, 0, 0, 0.1)';
        ctx.fillRect(0, h - 30, w, 30);
      }
    }

    private gameLoop = () => {
      this.update();
      this.draw();
      requestAnimationFrame(this.gameLoop);
    }
  }

  // å•Ÿå‹•éŠæˆ²
  new StairsGame();
</script>
